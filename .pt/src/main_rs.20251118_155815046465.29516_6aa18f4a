// File: src/main.rs
// Author: Hadi Cahyadi <cumulus13@gmail.com>
// Date: 2025-10-30
// Description: Production-hardened clipboard-to-file tool (Rust implementation)
// License: MIT

use chrono::{DateTime, Local};
use clap::{Parser, Subcommand};
use copypasta::{ClipboardContext, ClipboardProvider};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::io::{self, BufRead, Write};
use std::path::{Path, PathBuf};
use std::process::{Command, exit};
use std::time::SystemTime;
use walkdir::WalkDir;

// ANSI Color codes
const COLOR_RESET: &str = "\x1b[0m";
const COLOR_CYAN: &str = "\x1b[96m";
const COLOR_YELLOW: &str = "\x1b[93m";
const COLOR_GREEN: &str = "\x1b[92m";
const COLOR_GRAY: &str = "\x1b[90m";
const COLOR_BOLD: &str = "\x1b[1m";
const COLOR_RED: &str = "\x1b[91m";
const COLOR_BLUE: &str = "\x1b[94m";

// Configuration constants
const DEFAULT_MAX_CLIPBOARD_SIZE: usize = 100 * 1024 * 1024; // 100MB
const DEFAULT_MAX_BACKUP_COUNT: usize = 100;
const DEFAULT_MAX_FILENAME_LEN: usize = 200;
const DEFAULT_BACKUP_DIR_NAME: &str = "backup";
const DEFAULT_MAX_SEARCH_DEPTH: usize = 10;

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Config {
    #[serde(default = "default_max_clipboard_size")]
    max_clipboard_size: usize,
    #[serde(default = "default_max_backup_count")]
    max_backup_count: usize,
    #[serde(default = "default_max_filename_len")]
    max_filename_length: usize,
    #[serde(default = "default_backup_dir_name")]
    backup_dir_name: String,
    #[serde(default = "default_max_search_depth")]
    max_search_depth: usize,
}

fn default_max_clipboard_size() -> usize { DEFAULT_MAX_CLIPBOARD_SIZE }
fn default_max_backup_count() -> usize { DEFAULT_MAX_BACKUP_COUNT }
fn default_max_filename_len() -> usize { DEFAULT_MAX_FILENAME_LEN }
fn default_backup_dir_name() -> String { DEFAULT_BACKUP_DIR_NAME.to_string() }
fn default_max_search_depth() -> usize { DEFAULT_MAX_SEARCH_DEPTH }

impl Default for Config {
    fn default() -> Self {
        Self {
            max_clipboard_size: DEFAULT_MAX_CLIPBOARD_SIZE,
            max_backup_count: DEFAULT_MAX_BACKUP_COUNT,
            max_filename_length: DEFAULT_MAX_FILENAME_LEN,
            backup_dir_name: DEFAULT_BACKUP_DIR_NAME.to_string(),
            max_search_depth: DEFAULT_MAX_SEARCH_DEPTH,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct BackupMetadata {
    comment: String,
    timestamp: DateTime<Local>,
    size: u64,
    original_file: String,
}

#[derive(Debug, Clone)]
struct BackupInfo {
    path: PathBuf,
    name: String,
    mod_time: SystemTime,
    size: u64,
    comment: String,
}

#[derive(Debug)]
struct FileSearchResult {
    path: PathBuf,
    size: u64,
    mod_time: SystemTime,
    depth: usize,
}

#[derive(Debug)]
struct TreeNode {
    name: String,
    path: PathBuf,
    is_dir: bool,
    size: u64,
    children: Vec<TreeNode>,
}

#[derive(Parser)]
#[command(author, version, about = "Clipboard to File Tool with Smart Version Management", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
    
    /// Filename for write operation
    #[arg(value_name = "FILENAME")]
    filename: Option<String>,
    
    /// Check mode - skip write if content identical
    #[arg(short, long)]
    check: bool,
    
    /// Comment/message for backup
    #[arg(short, long, value_name = "COMMENT")]
    message: Option<String>,
}

#[derive(Subcommand)]
enum Commands {
    /// Configuration management
    Config {
        #[command(subcommand)]
        subcommand: ConfigCommands,
    },
    /// Show directory tree
    #[command(name = "tree", visible_alias = "t")]
    Tree {
        /// Starting path
        path: Option<PathBuf>,
        /// Exceptions (comma-separated)
        #[arg(short, long)]
        exception: Option<String>,
    },
    /// Append clipboard to file
    #[command(name = "append", visible_alias = "+")]
    Append {
        filename: String,
        /// Comment for backup
        #[arg(short, long)]
        message: Option<String>,
    },
    /// List backups
    #[command(name = "list", visible_alias = "l")]
    List {
        filename: String,
    },
    /// Restore from backup
    #[command(name = "restore", visible_alias = "r")]
    Restore {
        filename: String,
        /// Use last backup
        #[arg(long)]
        last: bool,
        /// Comment for restore operation
        #[arg(short, long)]
        message: Option<String>,
    },
    /// Compare file with backup (using delta)
    #[command(name = "diff", visible_alias = "d")]
    Diff {
        filename: String,
        /// Use last backup
        #[arg(long)]
        last: bool,
    },
    /// Remove file (with backup)
    #[command(name = "remove", visible_alias = "rm")]
    Remove {
        filename: String,
        /// Comment for backup
        #[arg(short, long)]
        message: Option<String>,
    },
}

#[derive(Subcommand)]
enum ConfigCommands {
    /// Initialize sample config file
    Init {
        /// Config file path (default: pt.yml)
        path: Option<PathBuf>,
    },
    /// Show current configuration
    Show,
    /// Show config file path
    Path,
}

struct App {
    config: Config,
}

impl App {
    fn new() -> Self {
        let config = Self::load_config();
        Self { config }
    }

    fn load_version() -> String {
        let version_paths = vec![
            PathBuf::from("VERSION"),
            std::env::current_exe()
                .ok()
                .and_then(|p| p.parent().map(|p| p.join("VERSION")))
                .unwrap_or_default(),
        ];

        for path in version_paths {
            if let Ok(content) = fs::read_to_string(&path) {
                let version = content.trim()
                    .trim_start_matches("version")
                    .trim_start_matches('=')
                    .trim()
                    .trim_matches(|c| c == '"' || c == '\'')
                    .trim_start_matches('v');
                
                if !version.is_empty() {
                    eprintln!("Version loaded from: {:?} ({})", path, version);
                    return version.to_string();
                }
            }
        }
        
        eprintln!("VERSION file not found, using 'dev'");
        "dev".to_string()
    }

    fn find_config_file() -> Option<PathBuf> {
        let config_names = vec!["pt.yml", "pt.yaml", ".pt.yml", ".pt.yaml"];
        
        let mut search_paths = vec![
            PathBuf::from("."),
        ];

        if let Some(home) = dirs::home_dir() {
            search_paths.push(home.join(".config/pt"));
            search_paths.push(home.clone());
        }

        for base_path in search_paths {
            for config_name in &config_names {
                let config_path = base_path.join(config_name);
                if config_path.exists() {
                    return Some(config_path);
                }
            }
        }

        None
    }

    fn load_config() -> Config {
        match Self::find_config_file() {
            Some(path) => {
                eprintln!("Loading config from: {:?}", path);
                match fs::read_to_string(&path) {
                    Ok(content) => {
                        match serde_yaml::from_str::<Config>(&content) {
                            Ok(config) => {
                                eprintln!("Config loaded successfully: clipboard={}MB, backups={}, depth={}",
                                    config.max_clipboard_size / (1024 * 1024),
                                    config.max_backup_count,
                                    config.max_search_depth);
                                config
                            }
                            Err(e) => {
                                eprintln!("Warning: failed to parse config: {}, using defaults", e);
                                Config::default()
                            }
                        }
                    }
                    Err(e) => {
                        eprintln!("Warning: failed to read config: {}, using defaults", e);
                        Config::default()
                    }
                }
            }
            None => {
                eprintln!("No config file found, using defaults");
                Config::default()
            }
        }
    }

    fn format_size(size: u64) -> String {
        const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB", "PB"];
        let mut size = size as f64;
        let mut unit_index = 0;

        while size >= 1024.0 && unit_index < UNITS.len() - 1 {
            size /= 1024.0;
            unit_index += 1;
        }

        format!("{:.1} {}", size, UNITS[unit_index])
    }

    fn get_clipboard_text(&self) -> Result<String, Box<dyn std::error::Error>> {
        let mut ctx = ClipboardContext::new()
            .map_err(|e| format!("Failed to access clipboard: {}", e))?;
        
        let text = ctx.get_contents()
            .map_err(|e| format!("Failed to read clipboard: {}", e))?;

        if text.len() > self.config.max_clipboard_size {
            return Err(format!("Clipboard content too large (max {}MB)",
                self.config.max_clipboard_size / (1024 * 1024)).into());
        }

        Ok(text)
    }

    fn validate_path(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        if path.as_os_str().is_empty() {
            return Err("Filename cannot be empty".into());
        }

        let path_str = path.to_string_lossy();
        if path_str.contains("..") {
            return Err("Path traversal not allowed".into());
        }

        if let Some(filename) = path.file_name() {
            if filename.len() > self.config.max_filename_length {
                return Err(format!("Filename too long (max {} characters)",
                    self.config.max_filename_length).into());
            }
        }

        // Check system directories
        let system_dirs = vec!["/etc", "/sys", "/proc", "/dev", "C:\\Windows", "C:\\System32"];
        let abs_path = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());
        
        for sys_dir in system_dirs {
            if abs_path.starts_with(sys_dir) {
                return Err("Writing to system directories not allowed".into());
            }
        }

        Ok(())
    }

    fn ensure_backup_dir(&self, file_path: &Path) -> Result<PathBuf, Box<dyn std::error::Error>> {
        let dir = file_path.parent().unwrap_or_else(|| Path::new("."));
        let backup_dir = dir.join(&self.config.backup_dir_name);

        if !backup_dir.exists() {
            fs::create_dir_all(&backup_dir)?;
            println!("üìÅ Created backup directory: {}", backup_dir.display());
        }

        Ok(backup_dir)
    }

    fn generate_unique_backup_name(&self, file_path: &Path) -> String {
        let file_name = file_path.file_name().unwrap().to_string_lossy();
        let extension = file_path.extension()
            .map(|e| e.to_string_lossy().to_string())
            .unwrap_or_default();
        
        let name_without_ext = if !extension.is_empty() {
            file_name.trim_end_matches(&format!(".{}", extension))
        } else {
            file_name.as_ref()
        };

        let timestamp = Local::now().format("%Y%m%d_%H%M%S%6f").to_string();
        let pid = std::process::id();
        let random_id = format!("{:x}", rand::random::<u32>());

        if !extension.is_empty() {
            format!("{}_{}.{}.{}_{}", name_without_ext, extension, timestamp, pid, random_id)
        } else {
            format!("{}.{}.{}_{}", name_without_ext, timestamp, pid, random_id)
        }
    }

    fn save_backup_metadata(&self, backup_path: &Path, comment: &str, original: &Path, size: u64) 
        -> Result<(), Box<dyn std::error::Error>> 
    {
        let metadata = BackupMetadata {
            comment: comment.to_string(),
            timestamp: Local::now(),
            size,
            original_file: original.to_string_lossy().to_string(),
        };

        let metadata_path = backup_path.with_extension("meta.json");
        let json = serde_json::to_string_pretty(&metadata)?;
        fs::write(metadata_path, json)?;

        Ok(())
    }

    fn load_backup_metadata(&self, backup_path: &Path) -> Result<String, Box<dyn std::error::Error>> {
        let metadata_path = format!("{}.meta.json", backup_path.display());
        let metadata_path = Path::new(&metadata_path);

        if !metadata_path.exists() {
            return Ok(String::new());
        }

        let content = fs::read_to_string(metadata_path)?;
        let metadata: BackupMetadata = serde_json::from_str(&content)?;
        Ok(metadata.comment)
    }

    fn auto_rename_if_exists(&self, file_path: &Path, comment: &str) 
        -> Result<(), Box<dyn std::error::Error>> 
    {
        if !file_path.exists() {
            return Ok(());
        }

        let metadata = fs::metadata(file_path)?;
        if metadata.len() == 0 {
            eprintln!("Skipping backup of empty file: {}", file_path.display());
            return Ok(());
        }

        let backup_dir = self.ensure_backup_dir(file_path)?;
        let backup_name = self.generate_unique_backup_name(file_path);
        let backup_path = backup_dir.join(&backup_name);

        fs::copy(file_path, &backup_path)?;
        self.save_backup_metadata(&backup_path, comment, file_path, metadata.len())?;

        eprintln!("Backup created: {} -> {}", file_path.display(), backup_path.display());
        
        if !comment.is_empty() {
            eprintln!("Backup comment: {}", comment);
            println!("üì¶ Backup created: {}{}{}", COLOR_GREEN, backup_name, COLOR_RESET);
            println!("üí¨ Comment: \"{}{}{}", COLOR_CYAN, comment, COLOR_RESET);
        } else {
            println!("üì¶ Backup created: {}{}{}", COLOR_GREEN, backup_name, COLOR_RESET);
        }

        Ok(())
    }

    fn write_file(&self, file_path: &Path, data: &str, append: bool, check_mode: bool, comment: &str) 
        -> Result<(), Box<dyn std::error::Error>> 
    {
        self.validate_path(file_path)?;

        if check_mode && !append {
            if let Ok(existing) = fs::read_to_string(file_path) {
                if existing == data {
                    println!("‚ÑπÔ∏è  Content identical to current file, no changes needed");
                    println!("üìÑ File: {}", file_path.display());
                    return Ok(());
                }
                println!("üîç Content differs, proceeding with backup and write");
            }
        }

        if !append {
            self.auto_rename_if_exists(file_path, comment)?;
        }

        let mut file = if append {
            fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(file_path)?
        } else {
            fs::File::create(file_path)?
        };

        file.write_all(data.as_bytes())?;
        file.sync_all()?;

        let action = if append { "appended to" } else { "written to" };
        println!("‚úÖ Successfully {}: {}", action, file_path.display());
        println!("üìÑ Content size: {} characters", data.len());

        Ok(())
    }

    fn list_backups(&self, file_path: &Path) -> Result<Vec<BackupInfo>, Box<dyn std::error::Error>> {
        self.validate_path(file_path)?;

        let dir = file_path.parent().unwrap_or_else(|| Path::new("."));
        let backup_dir = dir.join(&self.config.backup_dir_name);

        if !backup_dir.exists() {
            return Ok(Vec::new());
        }

        let file_name = file_path.file_name().unwrap().to_string_lossy();
        let extension = file_path.extension()
            .map(|e| e.to_string_lossy().to_string())
            .unwrap_or_default();
        
        let name_without_ext = if !extension.is_empty() {
            file_name.trim_end_matches(&format!(".{}", extension))
        } else {
            file_name.as_ref()
        };

        let pattern = if !extension.is_empty() {
            format!("{}_{}", name_without_ext, extension)
        } else {
            name_without_ext.to_string()
        };

        let mut backups = Vec::new();

        for entry in fs::read_dir(backup_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if path.is_dir() {
                continue;
            }

            let name = entry.file_name().to_string_lossy().to_string();
            
            if name.ends_with(".meta.json") {
                continue;
            }

            if !name.starts_with(&pattern) {
                continue;
            }

            let metadata = entry.metadata()?;
            let comment = self.load_backup_metadata(&path).unwrap_or_default();

            backups.push(BackupInfo {
                path: path.clone(),
                name,
                mod_time: metadata.modified()?,
                size: metadata.len(),
                comment,
            });
        }

        backups.sort_by(|a, b| b.mod_time.cmp(&a.mod_time));

        if backups.len() > self.config.max_backup_count {
            backups.truncate(self.config.max_backup_count);
        }

        Ok(backups)
    }

    fn print_backup_table(&self, file_path: &Path, backups: &[BackupInfo]) {
        println!("\n{}üìÇ Backup files for '{}{}{}'{}'{}",
            COLOR_CYAN, COLOR_BOLD, file_path.display(), COLOR_RESET, COLOR_CYAN, COLOR_RESET);
        println!("{}Total: {} backup(s) (stored in ./{}/){}\n",
            COLOR_GRAY, backups.len(), self.config.backup_dir_name, COLOR_RESET);

        const COL1_WIDTH: usize = 40;
        const COL2_WIDTH: usize = 19;
        const COL3_WIDTH: usize = 12;
        const COL4_WIDTH: usize = 30;

        // Top border
        println!("{}‚îå{}‚î¨{}‚î¨{}‚î¨{}‚îê{}",
            COLOR_GRAY,
            "‚îÄ".repeat(COL1_WIDTH + 2),
            "‚îÄ".repeat(COL2_WIDTH + 2),
            "‚îÄ".repeat(COL3_WIDTH + 2),
            "‚îÄ".repeat(COL4_WIDTH + 2),
            COLOR_RESET);

        // Header
        println!("{}‚îÇ{} {}{}{:<width1$}{} {}‚îÇ{} {}{}{:<width2$}{} {}‚îÇ{} {}{}{:>width3$}{} {}‚îÇ{} {}{}{:<width4$}{} {}‚îÇ{}",
            COLOR_GRAY, COLOR_RESET,
            COLOR_BOLD, COLOR_YELLOW, "File Name", COLOR_RESET,
            COLOR_GRAY, COLOR_RESET,
            COLOR_BOLD, COLOR_YELLOW, "Modified", COLOR_RESET,
            COLOR_GRAY, COLOR_RESET,
            COLOR_BOLD, COLOR_YELLOW, "Size", COLOR_RESET,
            COLOR_GRAY, COLOR_RESET,
            COLOR_BOLD, COLOR_YELLOW, "Comment", COLOR_RESET,
            COLOR_GRAY, COLOR_RESET,
            width1 = COL1_WIDTH,
            width2 = COL2_WIDTH,
            width3 = COL3_WIDTH,
            width4 = COL4_WIDTH);

        // Separator
        println!("{}‚îú{}‚îº{}‚îº{}‚îº{}‚î§{}",
            COLOR_GRAY,
            "‚îÄ".repeat(COL1_WIDTH + 2),
            "‚îÄ".repeat(COL2_WIDTH + 2),
            "‚îÄ".repeat(COL3_WIDTH + 2),
            "‚îÄ".repeat(COL4_WIDTH + 2),
            COLOR_RESET);

        // Data rows
        for (i, backup) in backups.iter().enumerate() {
            let mut name = backup.name.clone();
            let max_name_len = COL1_WIDTH - 5;
            if name.len() > max_name_len {
                name.truncate(max_name_len - 3);
                name.push_str("...");
            }

            let datetime: DateTime<Local> = backup.mod_time.into();
            let mod_time = datetime.format("%Y-%m-%d %H:%M:%S").to_string();
            let size_str = Self::format_size(backup.size);
            
            let comment = if backup.comment.is_empty() {
                "-".to_string()
            } else {
                let mut c = backup.comment.clone();
                if c.len() > COL4_WIDTH {
                    c.truncate(COL4_WIDTH - 3);
                    c.push_str("...");
                }
                c
            };

            println!("{}‚îÇ{} {:>3}. {:<width1$} {}‚îÇ{} {:<width2$} {}‚îÇ{} {:>width3$} {}‚îÇ{} {:<width4$} {}‚îÇ{}",
                COLOR_GRAY, COLOR_RESET,
                i + 1, name,
                COLOR_GRAY, COLOR_RESET,
                mod_time,
                COLOR_GRAY, COLOR_RESET,
                size_str,
                COLOR_GRAY, COLOR_RESET,
                comment,
                COLOR_GRAY, COLOR_RESET,
                width1 = max_name_len,
                width2 = COL2_WIDTH,
                width3 = COL3_WIDTH,
                width4 = COL4_WIDTH);
        }

        // Bottom border
        println!("{}‚îî{}‚î¥{}‚î¥{}‚î¥{}‚îò{}\n",
            COLOR_GRAY,
            "‚îÄ".repeat(COL1_WIDTH + 2),
            "‚îÄ".repeat(COL2_WIDTH + 2),
            "‚îÄ".repeat(COL3_WIDTH + 2),
            "‚îÄ".repeat(COL4_WIDTH + 2),
            COLOR_RESET);
    }

    fn restore_backup(&self, backup_path: &Path, original_path: &Path, comment: &str) 
        -> Result<(), Box<dyn std::error::Error>> 
    {
        self.validate_path(original_path)?;

        let metadata = fs::metadata(backup_path)?;
        if metadata.len() > self.config.max_clipboard_size as u64 {
            return Err(format!("Backup file too large to restore (max {}MB)",
                self.config.max_clipboard_size / (1024 * 1024)).into());
        }

        let content = fs::read_to_string(backup_path)?;

        if original_path.exists() {
            let restore_comment = if comment.is_empty() {
                "Backup before restore"
            } else {
                comment
            };
            self.auto_rename_if_exists(original_path, restore_comment)?;
        }

        fs::write(original_path, &content)?;

        println!("‚úÖ Successfully restored: {}", original_path.display());
        println!("üì¶ From backup: {}", backup_path.file_name().unwrap().to_string_lossy());
        println!("üìÑ Content size: {} characters", content.len());
        
        if !comment.is_empty() {
            println!("üí¨ Restore comment: \"{}\"", comment);
        }

        Ok(())
    }

    fn search_file_recursive(&self, filename: &str) -> Result<Vec<FileSearchResult>, Box<dyn std::error::Error>> {
        let cwd = std::env::current_dir()?;
        let mut results = Vec::new();

        // Check current directory first
        let current_path = cwd.join(filename);
        if current_path.is_file() {
            let metadata = fs::metadata(&current_path)?;
            results.push(FileSearchResult {
                path: current_path.clone(),
                size: metadata.len(),
                mod_time: metadata.modified()?,
                depth: 0,
            });
        }

        // Walk directory tree
        for entry in WalkDir::new(&cwd)
            .max_depth(self.config.max_search_depth)
            .into_iter()
            .filter_entry(|e| {
                let name = e.file_name().to_string_lossy();
                name != self.config.backup_dir_name && !name.starts_with('.')
            })
        {
            let entry = entry?;
            
            if entry.file_type().is_file() 
                && entry.file_name().to_string_lossy() == filename 
                && entry.path() != current_path
            {
                let metadata = entry.metadata()?;
                let depth = entry.depth();
                
                results.push(FileSearchResult {
                    path: entry.path().to_path_buf(),
                    size: metadata.len(),
                    mod_time: metadata.modified()?,
                    depth,
                });
            }
        }

        Ok(results)
    }

    fn resolve_file_path(&self, filename: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {
        let path = Path::new(filename);
        
        if path.is_file() {
            return Ok(path.canonicalize()?);
        }

        println!("{}üîç Searching for '{}' in subdirectories...{}", COLOR_BLUE, filename, COLOR_RESET);
        
        let results = self.search_file_recursive(filename)?;

        if results.is_empty() {
            return Err(format!("File '{}' not found in current directory or subdirectories", filename).into());
        }

        if results.len() == 1 {
            println!("{}‚úì Found: {}{}", COLOR_GREEN, results[0].path.display(), COLOR_RESET);
            return Ok(results[0].path.clone());
        }

        // Multiple files found - prompt user
        self.print_search_results(&results);

        print!("Enter file number to use (1-{}) or 0 to cancel: ", results.len());
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        
        let choice: usize = input.trim().parse()
            .map_err(|_| "Invalid input: please enter a number")?;

        if choice == 0 {
            return Err("Operation cancelled".into());
        }

        if choice > results.len() {
            return Err(format!("Invalid selection: must be between 0 and {}", results.len()).into());
        }

        Ok(results[choice - 1].path.clone())
    }

    fn print_search_results(&self, results: &[FileSearchResult]) {
        println!("\n{}üîç Found {} file(s):{}\n", COLOR_CYAN, results.len(), COLOR_RESET);

        for (i, result) in results.iter().enumerate() {
            let datetime: DateTime<Local> = result.mod_time.into();
            println!("{}{}. {}{} - {} - {}",
                COLOR_GREEN,
                i + 1,
                result.path.display(),
                COLOR_RESET,
                datetime.format("%Y-%m-%d %H:%M:%S"),
                Self::format_size(result.size));
        }
        println!();
    }

    fn run_delta(&self, file1: &Path, file2: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let status = Command::new("delta")
            .arg(file1)
            .arg(file2)
            .status();

        match status {
            Ok(status) => {
                // Exit code 1 is normal for delta when files differ
                if status.code() == Some(1) || status.success() {
                    Ok(())
                } else {
                    Err("Delta execution failed".into())
                }
            }
            Err(e) if e.kind() == io::ErrorKind::NotFound => {
                Err("delta is not installed. Install it from: https://github.com/dandavison/delta".into())
            }
            Err(e) => Err(e.into()),
        }
    }

    fn handle_config_init(&self, path: Option<PathBuf>) -> Result<(), Box<dyn std::error::Error>> {
        let config_path = path.unwrap_or_else(|| PathBuf::from("pt.yml"));

        if config_path.exists() {
            println!("{}‚ö†Ô∏è  Warning: Config file already exists: {}{}",
                COLOR_YELLOW, config_path.display(), COLOR_RESET);
            print!("Overwrite? (y/N): ");
            io::stdout().flush()?;

            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let input = input.trim().to_lowercase();

            if input != "y" && input != "yes" {
                println!("‚ùå Cancelled");
                return Ok(());
            }
        }

        let config = Config::default();
        let yaml = serde_yaml::to_string(&config)?;
        
        let header = r#"# PT Configuration File
# This file configures the behavior of the PT tool
# All values are optional - if not specified, defaults will be used

# Maximum clipboard content size in bytes (default: 104857600 = 100MB)
# Range: 1 - 1073741824 (1GB)

"#;

        fs::write(&config_path, format!("{}{}", header, yaml))?;

        println!("‚úÖ Sample config file created: {}{}{}", COLOR_GREEN, config_path.display(), COLOR_RESET);
        println!("üìù Edit this file to customize PT behavior");

        Ok(())
    }

    fn handle_config_show(&self) {
        println!("\n{}Current PT Configuration:{}\n", COLOR_BOLD, COLOR_RESET);
        println!("{}Max Clipboard Size:{} {} bytes ({:.1} MB)",
            COLOR_CYAN, COLOR_RESET,
            self.config.max_clipboard_size,
            self.config.max_clipboard_size as f64 / (1024.0 * 1024.0));
        println!("{}Max Backup Count:{} {}", COLOR_CYAN, COLOR_RESET, self.config.max_backup_count);
        println!("{}Max Filename Length:{} {} characters", COLOR_CYAN, COLOR_RESET, self.config.max_filename_length);
        println!("{}Backup Directory:{} {}/", COLOR_CYAN, COLOR_RESET, self.config.backup_dir_name);
        println!("{}Max Search Depth:{} {} levels\n", COLOR_CYAN, COLOR_RESET, self.config.max_search_depth);

        match Self::find_config_file() {
            Some(path) => println!("{}Config loaded from:{} {}", COLOR_GRAY, COLOR_RESET, path.display()),
            None => println!("{}Using default configuration (no config file found){}", COLOR_GRAY, COLOR_RESET),
        }
    }

    fn handle_config_path(&self) {
        match Self::find_config_file() {
            Some(path) => {
                println!("üìÑ Config file: {}{}{}", COLOR_GREEN, path.display(), COLOR_RESET);
            }
            None => {
                println!("{}‚ÑπÔ∏è  No config file found{}", COLOR_GRAY, COLOR_RESET);
                println!("\nSearched in:");
                println!("  ‚Ä¢ ./pt.yml or ./pt.yaml");
                println!("  ‚Ä¢ ~/.config/pt/pt.yml or ~/.config/pt/pt.yaml");
                println!("  ‚Ä¢ ~/pt.yml or ~/pt.yaml");
                println!("\n{}Create one with:{} pt config init", COLOR_CYAN, COLOR_RESET);
            }
        }
    }

    fn handle_tree(&self, path: Option<PathBuf>, exceptions: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
        let start_path = path.unwrap_or_else(|| PathBuf::from("."));
        let abs_path = start_path.canonicalize()?;

        let exception_set: HashMap<String, bool> = if let Some(exc) = exceptions {
            exc.split(',')
                .map(|s| (s.trim().to_string(), true))
                .collect()
        } else {
            HashMap::new()
        };

        let gitignore = self.load_gitignore(&abs_path)?;
        let tree = self.build_tree(&abs_path, &gitignore, &exception_set, 0)?;

        if let Some(tree) = tree {
            println!("\n{}{}{}", COLOR_BOLD, tree.name, COLOR_RESET);
            if tree.is_dir && !tree.children.is_empty() {
                for (i, child) in tree.children.iter().enumerate() {
                    let is_last = i == tree.children.len() - 1;
                    self.print_tree(child, "", is_last, true);
                }
            }
            println!();

            let (dir_count, file_count, total_size) = self.count_nodes(&tree);
            println!("{}{} directories, {} files, {} total{}",
                COLOR_GRAY, dir_count, file_count, Self::format_size(total_size), COLOR_RESET);

            if !exception_set.is_empty() {
                let exceptions: Vec<String> = exception_set.keys().cloned().collect();
                println!("{}Exceptions: {}{}", COLOR_GRAY, exceptions.join(", "), COLOR_RESET);
            }

            if !gitignore.is_empty() {
                println!("{}Using .gitignore ({} patterns){}", COLOR_GRAY, gitignore.len(), COLOR_RESET);
            }
        } else {
            println!("No files to display");
        }

        Ok(())
    }

    fn load_gitignore(&self, root_path: &Path) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let gitignore_path = root_path.join(".gitignore");
        let mut patterns = Vec::new();

        if gitignore_path.exists() {
            let file = fs::File::open(gitignore_path)?;
            let reader = io::BufReader::new(file);

            for line in reader.lines() {
                let line = line?;
                let trimmed = line.trim();
                if !trimmed.is_empty() && !trimmed.starts_with('#') {
                    patterns.push(trimmed.to_string());
                }
            }
        }

        Ok(patterns)
    }

    fn should_ignore(&self, path: &Path, is_dir: bool, patterns: &[String]) -> bool {
        let name = path.file_name().unwrap_or_default().to_string_lossy();

        for pattern in patterns {
            if pattern.ends_with('/') {
                let dir_pattern = pattern.trim_end_matches('/');
                if is_dir && name == dir_pattern {
                    return true;
                }
            } else if pattern.contains('*') {
                // Simple wildcard matching
                if Self::matches_pattern(&name, pattern) {
                    return true;
                }
            } else if name.as_ref() == pattern {
                return true;
            }
        }

        false
    }

    fn matches_pattern(name: &str, pattern: &str) -> bool {
        // Simple glob matching
        let pattern = pattern.replace("*", ".*");
        if let Ok(regex) = regex::Regex::new(&format!("^{}$", pattern)) {
            regex.is_match(name)
        } else {
            false
        }
    }

    fn build_tree(&self, path: &Path, gitignore: &[String], exceptions: &HashMap<String, bool>, depth: usize) 
        -> Result<Option<TreeNode>, Box<dyn std::error::Error>> 
    {
        if depth > self.config.max_search_depth {
            return Ok(None);
        }

        let metadata = fs::metadata(path)?;
        let name = path.file_name().unwrap_or_default().to_string_lossy().to_string();

        if exceptions.contains_key(&name) {
            return Ok(None);
        }

        if self.should_ignore(path, metadata.is_dir(), gitignore) {
            return Ok(None);
        }

        let mut node = TreeNode {
            name: name.clone(),
            path: path.to_path_buf(),
            is_dir: metadata.is_dir(),
            size: metadata.len(),
            children: Vec::new(),
        };

        if metadata.is_dir() {
            if let Ok(entries) = fs::read_dir(path) {
                for entry in entries.flatten() {
                    if let Ok(Some(child)) = self.build_tree(&entry.path(), gitignore, exceptions, depth + 1) {
                        node.children.push(child);
                    }
                }

                node.children.sort_by(|a, b| {
                    match (a.is_dir, b.is_dir) {
                        (true, false) => std::cmp::Ordering::Less,
                        (false, true) => std::cmp::Ordering::Greater,
                        _ => a.name.cmp(&b.name),
                    }
                });
            }
        }

        Ok(Some(node))
    }

    fn print_tree(&self, node: &TreeNode, prefix: &str, is_last: bool, show_size: bool) {
        let connector = if is_last { "‚îî‚îÄ‚îÄ " } else { "‚îú‚îÄ‚îÄ " };

        let display_name = if node.is_dir {
            format!("{}{}/{}", COLOR_CYAN, node.name, COLOR_RESET)
        } else {
            format!("{}{}{}", COLOR_GREEN, node.name, COLOR_RESET)
        };

        let size_str = if show_size && !node.is_dir {
            format!("{} ({}){}", COLOR_GRAY, Self::format_size(node.size), COLOR_RESET)
        } else {
            String::new()
        };

        println!("{}{}{}{}", prefix, connector, display_name, size_str);

        if node.is_dir && !node.children.is_empty() {
            let child_prefix = format!("{}{}", prefix, if is_last { "    " } else { "‚îÇ   " });

            for (i, child) in node.children.iter().enumerate() {
                let is_last_child = i == node.children.len() - 1;
                self.print_tree(child, &child_prefix, is_last_child, show_size);
            }
        }
    }

    fn count_nodes(&self, node: &TreeNode) -> (usize, usize, u64) {
        let mut dirs = 0;
        let mut files = 0;
        let mut total_size = 0u64;

        if node.is_dir {
            dirs += 1;
            for child in &node.children {
                let (d, f, s) = self.count_nodes(child);
                dirs += d;
                files += f;
                total_size += s;
            }
        } else {
            files += 1;
            total_size += node.size;
        }

        (dirs, files, total_size)
    }

    fn handle_remove(&self, filename: &str, comment: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
        let file_path = self.resolve_file_path(filename)?;
        let metadata = fs::metadata(&file_path)?;

        if metadata.is_dir() {
            return Err("Cannot remove directories, only files".into());
        }

        if metadata.len() > 0 {
            let backup_comment = comment.as_deref().unwrap_or("Deleted file backup");
            self.auto_rename_if_exists(&file_path, backup_comment)?;
        }

        let content = fs::read(&file_path)?;
        fs::remove_file(&file_path)?;

        println!("üóëÔ∏è  File deleted: {}", file_path.display());

        // Create empty placeholder
        fs::File::create(&file_path)?;

        println!("üìÑ Created empty placeholder: {}", file_path.display());
        println!("‚ÑπÔ∏è  Original content ({} bytes) backed up to ./{}/",
            content.len(), self.config.backup_dir_name);

        Ok(())
    }

    fn handle_list(&self, filename: &str) -> Result<(), Box<dyn std::error::Error>> {
        let file_path = self.resolve_file_path(filename)?;
        let backups = self.list_backups(&file_path)?;

        if backups.is_empty() {
            println!("‚ÑπÔ∏è  No backups found for: {} (check ./{}/ directory)",
                file_path.display(), self.config.backup_dir_name);
        } else {
            self.print_backup_table(&file_path, &backups);
        }

        Ok(())
    }

    fn handle_restore(&self, filename: &str, use_last: bool, comment: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
        let file_path = match self.resolve_file_path(filename) {
            Ok(path) => path,
            Err(_) => {
                // File may not exist yet (we're restoring it)
                PathBuf::from(filename).canonicalize()
                    .unwrap_or_else(|_| PathBuf::from(filename))
            }
        };

        let backups = self.list_backups(&file_path)?;

        if backups.is_empty() {
            return Err(format!("No backups found for: {} (check ./{}/)",
                file_path.display(), self.config.backup_dir_name).into());
        }

        if use_last {
            let restore_comment = comment.as_deref().unwrap_or("Restored from last backup");
            self.restore_backup(&backups[0].path, &file_path, restore_comment)?;
        } else {
            self.print_backup_table(&file_path, &backups);

            print!("Enter backup number to restore (1-{}) or 0 to cancel: ", backups.len());
            io::stdout().flush()?;

            let mut input = String::new();
            io::stdin().read_line(&mut input)?;

            let choice: usize = input.trim().parse()
                .map_err(|_| "Invalid input: please enter a number")?;

            if choice == 0 {
                println!("‚ùå Restore cancelled");
                return Ok(());
            }

            if choice > backups.len() {
                return Err(format!("Invalid selection: must be between 0 and {}", backups.len()).into());
            }

            let restore_comment = comment.as_deref().unwrap_or("Restored from backup");
            self.restore_backup(&backups[choice - 1].path, &file_path, restore_comment)?;
        }

        Ok(())
    }

    fn handle_diff(&self, filename: &str, use_last: bool) -> Result<(), Box<dyn std::error::Error>> {
        let file_path = self.resolve_file_path(filename)?;
        let backups = self.list_backups(&file_path)?;

        if backups.is_empty() {
            return Err(format!("No backups found for: {} (check ./{}/)",
                file_path.display(), self.config.backup_dir_name).into());
        }

        let selected_backup = if use_last {
            println!("{}üìä Comparing with last backup: {}{}\n",
                COLOR_CYAN, backups[0].name, COLOR_RESET);
            &backups[0]
        } else {
            self.print_backup_table(&file_path, &backups);

            print!("Enter backup number to compare (1-{}) or 0 to cancel: ", backups.len());
            io::stdout().flush()?;

            let mut input = String::new();
            io::stdin().read_line(&mut input)?;

            let choice: usize = input.trim().parse()
                .map_err(|_| "Invalid input: please enter a number")?;

            if choice == 0 {
                return Err("Diff cancelled".into());
            }

            if choice > backups.len() {
                return Err(format!("Invalid selection: must be between 0 and {}", backups.len()).into());
            }

            println!("\n{}üìä Comparing with: {}{}\n", COLOR_CYAN, backups[choice - 1].name, COLOR_RESET);
            &backups[choice - 1]
        };

        self.run_delta(&selected_backup.path, &file_path)?;

        Ok(())
    }

    fn handle_append(&self, filename: &str, comment: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
        let text = self.get_clipboard_text()?;

        if text.is_empty() {
            println!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", COLOR_YELLOW, COLOR_RESET);
            return Ok(());
        }

        let file_path = match self.resolve_file_path(filename) {
            Ok(path) => path,
            Err(_) => PathBuf::from(filename),
        };

        let backup_comment = comment.as_deref().unwrap_or("");
        self.write_file(&file_path, &text, true, false, backup_comment)?;

        Ok(())
    }

    fn handle_write(&self, filename: &str, check_mode: bool, comment: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
        let text = self.get_clipboard_text()?;

        if text.is_empty() {
            println!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", COLOR_YELLOW, COLOR_RESET);
            return Ok(());
        }

        let file_path = match self.resolve_file_path(filename) {
            Ok(path) => path,
            Err(_) => PathBuf::from(filename),
        };

        if check_mode {
            println!("üîç Check mode enabled - will skip if content identical");
        }

        let backup_comment = comment.as_deref().unwrap_or("");
        self.write_file(&file_path, &text, false, check_mode, backup_comment)?;

        Ok(())
    }
}

fn main() {
    let app = App::new();
    
    let cli = Cli::parse();

    let result = match cli.command {
        Some(Commands::Config { subcommand }) => {
            match subcommand {
                ConfigCommands::Init { path } => app.handle_config_init(path),
                ConfigCommands::Show => {
                    app.handle_config_show();
                    Ok(())
                }
                ConfigCommands::Path => {
                    app.handle_config_path();
                    Ok(())
                }
            }
        }
        Some(Commands::Tree { path, exception }) => {
            app.handle_tree(path, exception)
        }
        Some(Commands::Remove { filename, message }) => {
            app.handle_remove(&filename, message)
        }
        Some(Commands::List { filename }) => {
            app.handle_list(&filename)
        }
        Some(Commands::Restore { filename, last, message }) => {
            app.handle_restore(&filename, last, message)
        }
        Some(Commands::Diff { filename, last }) => {
            app.handle_diff(&filename, last)
        }
        Some(Commands::Append { filename, message }) => {
            app.handle_append(&filename, message)
        }
        None => {
            // Default write mode
            if let Some(filename) = cli.filename {
                app.handle_write(&filename, cli.check, cli.message)
            } else {
                println!("{}‚ùå Error: Filename required{}", COLOR_RED, COLOR_RESET);
                exit(1);
            }
        }
    };

    if let Err(e) = result {
        eprintln!("{}‚ùå Error: {}{}", COLOR_RED, e, COLOR_RESET);
        exit(1);
    }
}