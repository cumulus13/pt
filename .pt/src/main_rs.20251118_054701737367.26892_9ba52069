// File: src/main.rs
// Author: Hadi Cahyadi <cumulus13@gmail.com>
// Date: 2025-10-30
// Description: Production-hardened clipboard-to-file tool with security, validation, and robustness improvements
// License: MIT

use anyhow::{Context, Result, anyhow};
use chrono::Local;
use clap::{Parser, Subcommand};
use clipboard::{ClipboardContext, ClipboardProvider};
use colored::*;
use rand::Rng;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, File, OpenOptions};
use std::io::{self, BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use std::process;
use walkdir::WalkDir;

// Configuration constants (defaults)
const DEFAULT_MAX_CLIPBOARD_SIZE: usize = 100 * 1024 * 1024; // 100MB
const DEFAULT_MAX_BACKUP_COUNT: usize = 100;
const DEFAULT_MAX_FILENAME_LEN: usize = 200;
const DEFAULT_BACKUP_DIR_NAME: &str = "backup";
const DEFAULT_MAX_SEARCH_DEPTH: usize = 10;

// Version from Cargo.toml
const VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Debug, Serialize, Deserialize, Clone)]
struct Config {
    max_clipboard_size: usize,
    max_backup_count: usize,
    max_filename_length: usize,
    backup_dir_name: String,
    max_search_depth: usize,
}

impl Default for Config {
    fn default() -> Self {
        Config {
            max_clipboard_size: DEFAULT_MAX_CLIPBOARD_SIZE,
            max_backup_count: DEFAULT_MAX_BACKUP_COUNT,
            max_filename_length: DEFAULT_MAX_FILENAME_LEN,
            backup_dir_name: DEFAULT_BACKUP_DIR_NAME.to_string(),
            max_search_depth: DEFAULT_MAX_SEARCH_DEPTH,
        }
    }
}

#[derive(Debug)]
struct BackupInfo {
    path: PathBuf,
    name: String,
    mod_time: std::time::SystemTime,
    size: u64,
}

#[derive(Debug)]
struct FileSearchResult {
    path: PathBuf,
    #[allow(dead_code)]
    dir: PathBuf,
    size: u64,
    mod_time: std::time::SystemTime,
    #[allow(dead_code)]
    depth: usize,
}

#[derive(Debug)]
struct TreeNode {
    name: String,
    #[allow(dead_code)]
    path: PathBuf,
    is_dir: bool,
    size: u64,
    children: Vec<TreeNode>,
}

#[derive(Debug)]
struct GitIgnore {
    patterns: Vec<String>,
}

#[derive(Parser)]
#[command(name = "pt")]
#[command(about = "Clipboard to File Tool with Smart Version Management", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
    
    /// Filename to write clipboard content
    filename: Option<String>,
    
    /// Write only if content differs (check mode)
    #[arg(short = 'c', long = "check")]
    check_mode: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Append clipboard to file
    #[command(name = "+")]
    Append {
        filename: String,
    },
    
    /// List backups for a file
    #[command(name = "list", visible_alias = "l")]
    List {
        filename: String,
    },
    
    /// Restore a backup
    #[command(name = "restore", visible_alias = "r")]
    Restore {
        filename: String,
        /// Restore the last backup
        #[arg(long)]
        last: bool,
    },
    
    /// Compare file with backup using delta
    #[command(name = "diff", visible_alias = "d")]
    Diff {
        filename: String,
        /// Compare with last backup
        #[arg(long)]
        last: bool,
    },
    
    /// Delete file (with backup) and create empty placeholder
    #[command(name = "remove", visible_alias = "rm")]
    Remove {
        filename: String,
    },
    
    /// Show directory tree
    #[command(name = "tree", visible_alias = "t")]
    Tree {
        /// Path to display tree
        path: Option<String>,
        /// Exceptions (comma-separated)
        #[arg(short = 'e', long = "exception")]
        exceptions: Option<String>,
    },
    
    /// Configuration management
    Config {
        #[command(subcommand)]
        subcommand: ConfigCommands,
    },
}

#[derive(Subcommand)]
enum ConfigCommands {
    /// Create sample config file
    Init {
        /// Path for config file (default: pt.yml)
        path: Option<String>,
    },
    /// Show current configuration
    Show,
    /// Show config file location
    Path,
}

// Load configuration
fn load_config() -> Config {
    let config_paths = vec![
        PathBuf::from("pt.yml"),
        PathBuf::from("pt.yaml"),
        PathBuf::from(".pt.yml"),
        PathBuf::from(".pt.yaml"),
    ];
    
    // Add home directory paths
    if let Some(home) = dirs::home_dir() {
        let home_paths = vec![
            home.join(".config/pt/pt.yml"),
            home.join(".config/pt/pt.yaml"),
            home.join("pt.yml"),
            home.join("pt.yaml"),
        ];
        
        config_paths.into_iter()
            .chain(home_paths)
            .find_map(|path| {
                if path.exists() {
                    eprintln!("Loading config from: {}", path.display());
                    fs::read_to_string(&path)
                        .ok()
                        .and_then(|content| serde_yaml::from_str(&content).ok())
                } else {
                    None
                }
            })
            .unwrap_or_else(|| {
                eprintln!("No config file found, using defaults");
                Config::default()
            })
    } else {
        Config::default()
    }
}

fn find_config_file() -> Option<PathBuf> {
    let config_names = vec!["pt.yml", "pt.yaml", ".pt.yml", ".pt.yaml"];
    
    let mut search_paths = vec![PathBuf::from(".")];
    
    if let Some(home) = dirs::home_dir() {
        search_paths.push(home.join(".config/pt"));
        search_paths.push(home.clone());
    }
    
    for base_path in search_paths {
        for config_name in &config_names {
            let config_path = base_path.join(config_name);
            if config_path.exists() {
                return Some(config_path);
            }
        }
    }
    
    None
}

fn generate_sample_config(path: &Path) -> Result<()> {
    let config = Config::default();
    let yaml = serde_yaml::to_string(&config)?;
    
    let header = r#"# PT Configuration File
# This file configures the behavior of the PT tool
# All values are optional - if not specified, defaults will be used

# Maximum clipboard content size in bytes (default: 104857600 = 100MB)
# Range: 1 - 1073741824 (1GB)
"#;
    
    let full_content = format!("{}{}", header, yaml);
    
    fs::write(path, full_content)?;
    Ok(())
}

fn format_size(size: u64) -> String {
    const UNIT: f64 = 1024.0;
    if size < 1024 {
        return format!("{} B", size);
    }
    
    let size_f = size as f64;
    let exp = (size_f.ln() / UNIT.ln()).floor() as i32;
    let value = size_f / UNIT.powi(exp);
    let unit = ['K', 'M', 'G', 'T', 'P', 'E'][(exp - 1) as usize];
    
    format!("{:.1} {}B", value, unit)
}

impl GitIgnore {
    fn load(root_path: &Path) -> Result<Self> {
        let gitignore_path = root_path.join(".gitignore");
        let mut patterns = Vec::new();
        
        if let Ok(file) = File::open(&gitignore_path) {
            let reader = BufReader::new(file);
            for line in reader.lines() {
                if let Ok(line) = line {
                    let trimmed = line.trim();
                    if !trimmed.is_empty() && !trimmed.starts_with('#') {
                        patterns.push(trimmed.to_string());
                    }
                }
            }
        }
        
        Ok(GitIgnore { patterns })
    }
    
    fn should_ignore(&self, path: &Path, is_dir: bool) -> bool {
        let base_name = path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("");
        
        for pattern in &self.patterns {
            if pattern.ends_with('/') {
                let dir_pattern = pattern.trim_end_matches('/');
                if is_dir && (base_name == dir_pattern || base_name.starts_with(dir_pattern)) {
                    return true;
                }
                continue;
            }
            
            if pattern.contains('*') {
                if let Ok(glob) = glob::Pattern::new(pattern) {
                    if glob.matches(base_name) {
                        return true;
                    }
                }
                continue;
            }
            
            if base_name == pattern {
                return true;
            }
            
            if let Some(path_str) = path.to_str() {
                if path_str.contains(&format!("/{}/", pattern)) || 
                   path_str.contains(&format!("\\{}\\", pattern)) {
                    return true;
                }
            }
        }
        
        false
    }
}

fn build_tree(
    path: &Path,
    gitignore: &Option<GitIgnore>,
    exceptions: &HashMap<String, bool>,
    depth: usize,
    max_depth: usize,
) -> Result<Option<TreeNode>> {
    if depth > max_depth {
        return Ok(None);
    }
    
    let metadata = fs::metadata(path)?;
    let base_name = path.file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("")
        .to_string();
    
    if exceptions.contains_key(&base_name) {
        return Ok(None);
    }
    
    if let Some(gi) = gitignore {
        if gi.should_ignore(path, metadata.is_dir()) {
            return Ok(None);
        }
    }
    
    let mut node = TreeNode {
        name: base_name,
        path: path.to_path_buf(),
        is_dir: metadata.is_dir(),
        size: metadata.len(),
        children: Vec::new(),
    };
    
    if metadata.is_dir() {
        if let Ok(entries) = fs::read_dir(path) {
            for entry in entries.flatten() {
                if let Ok(Some(child_node)) = build_tree(
                    &entry.path(),
                    gitignore,
                    exceptions,
                    depth + 1,
                    max_depth,
                ) {
                    node.children.push(child_node);
                }
            }
            
            node.children.sort_by(|a, b| {
                match (a.is_dir, b.is_dir) {
                    (true, false) => std::cmp::Ordering::Less,
                    (false, true) => std::cmp::Ordering::Greater,
                    _ => a.name.cmp(&b.name),
                }
            });
        }
    }
    
    Ok(Some(node))
}

fn print_tree(node: &TreeNode, prefix: &str, is_last: bool, show_size: bool) {
    let connector = if is_last { "‚îî‚îÄ‚îÄ " } else { "‚îú‚îÄ‚îÄ " };
    
    let display_name = if node.is_dir {
        format!("{}/", node.name).cyan()
    } else {
        node.name.green()
    };
    
    let size_str = if show_size && !node.is_dir {
        format!(" ({})", format_size(node.size)).bright_black()
    } else {
        "".bright_black()
    };
    
    println!("{}{}{}{}", prefix, connector, display_name, size_str);
    
    if node.is_dir && !node.children.is_empty() {
        let child_prefix = if is_last {
            format!("{}    ", prefix)
        } else {
            format!("{}‚îÇ   ", prefix)
        };
        
        for (i, child) in node.children.iter().enumerate() {
            print_tree(child, &child_prefix, i == node.children.len() - 1, show_size);
        }
    }
}

fn handle_tree_command(path_opt: Option<String>, exceptions_opt: Option<String>, config: &Config) -> Result<()> {
    let start_path = path_opt.unwrap_or_else(|| ".".to_string());
    let exceptions: HashMap<String, bool> = exceptions_opt
        .map(|s| {
            s.split(',')
                .map(|e| (e.trim().to_string(), true))
                .collect()
        })
        .unwrap_or_default();
    
    let abs_path = fs::canonicalize(&start_path)
        .with_context(|| format!("Invalid path: {}", start_path))?;
    
    let gitignore = if abs_path.is_dir() {
        GitIgnore::load(&abs_path).ok()
    } else {
        None
    };
    
    let tree = build_tree(&abs_path, &gitignore, &exceptions, 0, config.max_search_depth)?
        .ok_or_else(|| anyhow!("No files to display"))?;
    
    println!("\n{}", tree.name.bold());
    
    if tree.is_dir && !tree.children.is_empty() {
        for (i, child) in tree.children.iter().enumerate() {
            print_tree(child, "", i == tree.children.len() - 1, true);
        }
    }
    println!();
    
    let (mut file_count, mut dir_count, mut total_size) = (0, 0, 0u64);
    
    fn count_nodes(node: &TreeNode, file_count: &mut i32, dir_count: &mut i32, total_size: &mut u64) {
        if node.is_dir {
            *dir_count += 1;
            for child in &node.children {
                count_nodes(child, file_count, dir_count, total_size);
            }
        } else {
            *file_count += 1;
            *total_size += node.size;
        }
    }
    
    count_nodes(&tree, &mut file_count, &mut dir_count, &mut total_size);
    
    println!(
        "{}{} directories, {} files, {} total{}",
        "".bright_black(),
        dir_count,
        file_count,
        format_size(total_size),
        "".bright_black()
    );
    
    if !exceptions.is_empty() {
        let exc_list: Vec<_> = exceptions.keys().cloned().collect();
        println!("{}Exceptions: {}{}", "".bright_black(), exc_list.join(", "), "".bright_black());
    }
    
    if let Some(gi) = gitignore {
        if !gi.patterns.is_empty() {
            println!("{}Using .gitignore ({} patterns){}", "".bright_black(), gi.patterns.len(), "".bright_black());
        }
    }
    
    Ok(())
}

fn search_file_recursive(filename: &str, max_depth: usize) -> Result<Vec<FileSearchResult>> {
    let cwd = std::env::current_dir()?;
    let mut results = Vec::new();
    
    let current_path = cwd.join(filename);
    if let Ok(metadata) = fs::metadata(&current_path) {
        if !metadata.is_dir() {
            results.push(FileSearchResult {
                path: current_path.clone(),
                dir: cwd.clone(),
                size: metadata.len(),
                mod_time: metadata.modified()?,
                depth: 0,
            });
        }
    }
    
    for entry in WalkDir::new(&cwd)
        .max_depth(max_depth + 1)
        .into_iter()
        .filter_map(|e| e.ok())
    {
        let path = entry.path();
        let metadata = entry.metadata()?;
        
        if metadata.is_dir() && path.file_name().and_then(|n| n.to_str()) == Some("backup") {
            continue;
        }
        
        if !metadata.is_dir() && path.file_name().and_then(|n| n.to_str()) == Some(filename) {
            if path == current_path {
                continue;
            }
            
            let depth = path.strip_prefix(&cwd)?.components().count() - 1;
            
            results.push(FileSearchResult {
                path: path.to_path_buf(),
                dir: path.parent().unwrap_or(&cwd).to_path_buf(),
                size: metadata.len(),
                mod_time: metadata.modified()?,
                depth,
            });
        }
    }
    
    Ok(results)
}

fn print_file_search_results(results: &[FileSearchResult]) {
    println!("\n{}üîç Found {} file(s):{}\n", "".cyan(), results.len(), "".clear());
    
    const COL1_WIDTH: usize = 60;
    const COL2_WIDTH: usize = 19;
    const COL3_WIDTH: usize = 12;
    
    println!(
        "{}‚îå{}‚î¨{}‚î¨{}‚îê{}",
        "".bright_black(),
        "‚îÄ".repeat(COL1_WIDTH + 2),
        "‚îÄ".repeat(COL2_WIDTH + 2),
        "‚îÄ".repeat(COL3_WIDTH + 2),
        "".clear()
    );
    
    println!(
        "{}‚îÇ{} {}{:<width1$}{} {}‚îÇ{} {}{:<width2$}{} {}‚îÇ{} {:>width3$} {}‚îÇ",
        "".bright_black(), "".clear(),
        "".bold().yellow(), "Path", "".clear(),
        "".bright_black(), "".clear(),
        "".bold().yellow(), "Modified", "".clear(),
        "".bright_black(), "".clear(),
        "".bold().yellow(), "Size", "".clear(),
        width1 = COL1_WIDTH,
        width2 = COL2_WIDTH,
        width3 = COL3_WIDTH
    );
    
    println!(
        "{}‚îú{}‚îº{}‚îº{}‚î§{}",
        "".bright_black(),
        "‚îÄ".repeat(COL1_WIDTH + 2),
        "‚îÄ".repeat(COL2_WIDTH + 2),
        "‚îÄ".repeat(COL3_WIDTH + 2),
        "".clear()
    );
    
    for (i, result) in results.iter().enumerate() {
        let cwd = std::env::current_dir().unwrap();
        let rel_path = result.path.strip_prefix(&cwd)
            .unwrap_or(&result.path)
            .display()
            .to_string();
        
        let max_path_len = COL1_WIDTH - 5;
        let display_path = if rel_path.len() > max_path_len {
            format!("...{}", &rel_path[rel_path.len() - max_path_len + 3..])
        } else {
            rel_path
        };
        
        let mod_time = chrono::DateTime::<chrono::Local>::from(result.mod_time)
            .format("%Y-%m-%d %H:%M:%S")
            .to_string();
        
        let size_str = format_size(result.size);
        
        println!(
            "{}‚îÇ{} {}{:>3}. {:<width1$}{} {}‚îÇ{} {:<width2$} {}‚îÇ{} {:>width3$} {}‚îÇ",
            "".bright_black(), "".clear(),
            "".green(), i + 1, display_path, "".clear(),
            "".bright_black(), "".clear(),
            mod_time,
            "".bright_black(), "".clear(),
            size_str,
            "".bright_black(),
            width1 = max_path_len,
            width2 = COL2_WIDTH,
            width3 = COL3_WIDTH
        );
    }
    
    println!(
        "{}‚îî{}‚î¥{}‚î¥{}‚îò{}\n",
        "".bright_black(),
        "‚îÄ".repeat(COL1_WIDTH + 2),
        "‚îÄ".repeat(COL2_WIDTH + 2),
        "‚îÄ".repeat(COL3_WIDTH + 2),
        "".clear()
    );
}

fn resolve_file_path(filename: &str, config: &Config) -> Result<PathBuf> {
    if let Ok(metadata) = fs::metadata(filename) {
        if !metadata.is_dir() {
            return Ok(fs::canonicalize(filename)?);
        }
    }
    
    eprintln!("File not found in current directory, searching recursively...");
    println!("{}üîç Searching for '{}' in subdirectories...{}", "".blue(), filename, "".clear());
    
    let results = search_file_recursive(filename, config.max_search_depth)?;
    
    if results.is_empty() {
        return Err(anyhow!(
            "File '{}' not found in current directory or subdirectories",
            filename
        ));
    }
    
    if results.len() == 1 {
        println!("{}‚úì Found: {}{}", "".green(), results[0].path.display(), "".clear());
        return Ok(results[0].path.clone());
    }
    
    print_file_search_results(&results);
    
    print!("Enter file number to use (1-{}) or 0 to cancel: ", results.len());
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    let choice: usize = input.trim().parse()
        .with_context(|| "Invalid input: please enter a number")?;
    
    if choice == 0 {
        return Err(anyhow!("Operation cancelled"));
    }
    
    if choice > results.len() {
        return Err(anyhow!("Invalid selection: must be between 0 and {}", results.len()));
    }
    
    Ok(results[choice - 1].path.clone())
}

// Integrated delta diff function using similar library
fn run_delta_diff(file1: &Path, file2: &Path) -> Result<()> {
    use similar::{ChangeTag, TextDiff};
    
    // Read both files
    let content1 = fs::read_to_string(file1)?;
    let content2 = fs::read_to_string(file2)?;
    
    // Create diff
    let diff = TextDiff::from_lines(&content1, &content2);
    
    // Display with colors (similar to delta output)
    for change in diff.iter_all_changes() {
        let line = change.value();
        match change.tag() {
            ChangeTag::Delete => print!("{}", format!("-{}", line).red()),
            ChangeTag::Insert => print!("{}", format!("+{}", line).green()),
            ChangeTag::Equal => print!(" {}", line),
        }
    }
    
    Ok(())
}

fn handle_diff_command(filename: &str, use_last: bool, config: &Config) -> Result<()> {
    let file_path = resolve_file_path(filename, config)?;
    let backups = list_backups(&file_path, config)?;
    
    if backups.is_empty() {
        return Err(anyhow!(
            "No backups found for: {} (check ./{}/ directory)",
            file_path.display(),
            config.backup_dir_name
        ));
    }
    
    let selected_backup = if use_last {
        println!(
            "{}üìä Comparing with last backup: {}{}",
            "".cyan(),
            backups[0].name,
            "".clear()
        );
        &backups[0]
    } else {
        print_backup_table(&file_path, &backups, config)?;
        
        print!("Enter backup number to compare (1-{}) or 0 to cancel: ", backups.len());
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        
        let choice: usize = input.trim().parse()
            .with_context(|| "Invalid input: please enter a number")?;
        
        if choice == 0 {
            return Err(anyhow!("Diff cancelled"));
        }
        
        if choice > backups.len() {
            return Err(anyhow!("Invalid selection: must be between 0 and {}", backups.len()));
        }
        
        println!(
            "\n{}üìä Comparing with: {}{}\n",
            "".cyan(),
            backups[choice - 1].name,
            "".clear()
        );
        
        &backups[choice - 1]
    };
    
    run_delta_diff(&selected_backup.path, &file_path)?;
    
    Ok(())
}

fn ensure_backup_dir(file_path: &Path, config: &Config) -> Result<PathBuf> {
    let dir = file_path.parent().unwrap_or_else(|| Path::new("."));
    let backup_dir = dir.join(&config.backup_dir_name);
    
    if !backup_dir.exists() {
        fs::create_dir_all(&backup_dir)?;
        eprintln!("Created backup directory: {}", backup_dir.display());
        println!("üìÅ Created backup directory: {}", backup_dir.display());
    }
    
    Ok(backup_dir)
}

fn validate_path(file_path: &Path, config: &Config) -> Result<()> {
    let filename = file_path.file_name()
        .and_then(|n| n.to_str())
        .ok_or_else(|| anyhow!("Invalid filename"))?;
    
    if filename.len() > config.max_filename_length {
        return Err(anyhow!(
            "Filename too long (max {} characters)",
            config.max_filename_length
        ));
    }
    
    let path_str = file_path.to_str().unwrap_or("");
    if path_str.contains("..") {
        return Err(anyhow!("Path traversal not allowed"));
    }
    
    let system_dirs = vec!["/etc", "/sys", "/proc", "/dev", "C:\\Windows", "C:\\System32"];
    for sys_dir in system_dirs {
        if path_str.starts_with(sys_dir) {
            return Err(anyhow!("Writing to system directories not allowed"));
        }
    }
    
    Ok(())
}

fn generate_unique_backup_name(file_path: &Path) -> String {
    let base_name = file_path.file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("unknown");
    
    let ext = file_path.extension()
        .and_then(|e| e.to_str())
        .unwrap_or("");
    
    let name_without_ext = base_name.trim_end_matches(&format!(".{}", ext));
    
    let timestamp = Local::now().format("%Y%m%d_%H%M%S%6f").to_string();
    let unique_id = format!("{}_{:x}", process::id(), rand::thread_rng().gen::<u32>());
    
    if ext.is_empty() {
        format!("{}_{}.{}", name_without_ext, timestamp, unique_id)
    } else {
        format!("{}_{}.{}.{}", name_without_ext, ext, timestamp, unique_id)
    }
}

fn auto_rename_if_exists(file_path: &Path, config: &Config) -> Result<PathBuf> {
    if !file_path.exists() {
        return Ok(file_path.to_path_buf());
    }
    
    let metadata = fs::metadata(file_path)?;
    
    if metadata.len() == 0 {
        eprintln!("Skipping backup of empty file: {}", file_path.display());
        return Ok(file_path.to_path_buf());
    }
    
    let backup_dir = ensure_backup_dir(file_path, config)?;
    let backup_filename = generate_unique_backup_name(file_path);
    let backup_path = backup_dir.join(&backup_filename);
    
    let content = fs::read(file_path)?;
    fs::write(&backup_path, content)?;
    
    eprintln!("Backup created: {} -> {}", file_path.display(), backup_path.display());
    println!("üì¶ Backup created: {}{}{}", "".green(), backup_filename, "".clear());
    
    Ok(file_path.to_path_buf())
}

fn get_clipboard_text(config: &Config) -> Result<String> {
    let mut ctx: ClipboardContext = ClipboardProvider::new()
        .map_err(|e| anyhow!("Failed to access clipboard: {}", e))?;
    let text = ctx.get_contents()
        .map_err(|e| anyhow!("Failed to read clipboard: {}", e))?;
    
    if text.len() > config.max_clipboard_size {
        return Err(anyhow!(
            "Clipboard content too large (max {}MB)",
            config.max_clipboard_size / (1024 * 1024)
        ));
    }
    
    Ok(text)
}

fn write_file(
    file_path: &Path,
    data: &str,
    append_mode: bool,
    check_mode: bool,
    config: &Config,
) -> Result<()> {
    validate_path(file_path, config)?;
    
    if check_mode && !append_mode {
        if let Ok(existing_data) = fs::read_to_string(file_path) {
            if existing_data == data {
                eprintln!("Content identical, skipping write: {}", file_path.display());
                println!("‚ÑπÔ∏è  Content identical to current file, no changes needed");
                println!("üìÑ File: {}", file_path.display());
                return Ok(());
            }
            println!("üîç Content differs, proceeding with backup and write");
        }
    }
    
    if !append_mode {
        auto_rename_if_exists(file_path, config)?;
    }
    
    let mut file = if append_mode {
        OpenOptions::new()
            .create(true)
            .append(true)
            .open(file_path)?
    } else {
        File::create(file_path)?
    };
    
    file.write_all(data.as_bytes())?;
    file.sync_all()?;
    
    let action = if append_mode { "appended to" } else { "written to" };
    
    eprintln!("Successfully {}: {} ({} bytes)", action, file_path.display(), data.len());
    println!("‚úÖ Successfully {}: {}", action, file_path.display());
    println!("üìÑ Content size: {} characters", data.len());
    
    Ok(())
}

fn list_backups(file_path: &Path, config: &Config) -> Result<Vec<BackupInfo>> {
    validate_path(file_path, config)?;
    
    let dir = file_path.parent().unwrap_or_else(|| Path::new("."));
    let backup_dir = dir.join(&config.backup_dir_name);
    
    if !backup_dir.exists() {
        return Ok(Vec::new());
    }
    
    let base_name = file_path.file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("");
    
    let ext = file_path.extension()
        .and_then(|e| e.to_str())
        .unwrap_or("");
    
    let name_without_ext = base_name.trim_end_matches(&format!(".{}", ext));
    let pattern = if ext.is_empty() {
        format!("{}_", name_without_ext)
    } else {
        format!("{}_{}", name_without_ext, ext)
    };
    
    eprintln!("Looking for backups with pattern: {} in directory: {}", pattern, backup_dir.display());
    
    let mut backups = Vec::new();
    
    for entry in fs::read_dir(&backup_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_dir() {
            continue;
        }
        
        let name = entry.file_name();
        let name_str = name.to_str().unwrap_or("");
        
        if !name_str.starts_with(&pattern) {
            continue;
        }
        
        let timestamp = name_str.trim_start_matches(&pattern);
        
        if timestamp.len() < 20 {
            continue;
        }
        
        let digit_count = timestamp.chars().filter(|c| c.is_ascii_digit()).count();
        
        if digit_count < 14 {
            continue;
        }
        
        let metadata = fs::metadata(&path)?;
        
        backups.push(BackupInfo {
            path: path.clone(),
            name: name_str.to_string(),
            mod_time: metadata.modified()?,
            size: metadata.len(),
        });
    }
    
    backups.sort_by(|a, b| b.mod_time.cmp(&a.mod_time));
    
    if backups.len() > config.max_backup_count {
        backups.truncate(config.max_backup_count);
    }
    
    Ok(backups)
}

fn print_backup_table(file_path: &Path, backups: &[BackupInfo], config: &Config) -> Result<()> {
    const COL1_WIDTH: usize = 50;
    const COL2_WIDTH: usize = 19;
    const COL3_WIDTH: usize = 15;
    
    println!(
        "\n{}üìÇ Backup files for '{}{}{}{}'{}\n",
        "".cyan(),
        "".bold(),
        file_path.display(),
        "".clear(),
        "".cyan(),
        "".clear()
    );
    println!(
        "{}Total: {} backup(s) (stored in ./{}/){}",
        "".bright_black(),
        backups.len(),
        config.backup_dir_name,
        "".clear()
    );
    
    println!(
        "\n{}‚îå{}‚î¨{}‚î¨{}‚îê{}",
        "".bright_black(),
        "‚îÄ".repeat(COL1_WIDTH + 2),
        "‚îÄ".repeat(COL2_WIDTH + 2),
        "‚îÄ".repeat(COL3_WIDTH + 2),
        "".clear()
    );
    
    println!(
        "{}‚îÇ{} {}{:<width1$}{} {}‚îÇ{} {}{:<width2$}{} {}‚îÇ{} {:>width3$} {}‚îÇ",
        "".bright_black(), "".clear(),
        "".bold().yellow(), "File Name", "".clear(),
        "".bright_black(), "".clear(),
        "".bold().yellow(), "Modified", "".clear(),
        "".bright_black(), "".clear(),
        "".bold().yellow(), "Size", "".clear(),
        width1 = COL1_WIDTH,
        width2 = COL2_WIDTH,
        width3 = COL3_WIDTH
    );
    
    println!(
        "{}‚îú{}‚îº{}‚îº{}‚î§{}",
        "".bright_black(),
        "‚îÄ".repeat(COL1_WIDTH + 2),
        "‚îÄ".repeat(COL2_WIDTH + 2),
        "‚îÄ".repeat(COL3_WIDTH + 2),
        "".clear()
    );
    
    for (i, backup) in backups.iter().enumerate() {
        let name = &backup.name;
        let max_name_len = COL1_WIDTH - 5;
        let display_name = if name.len() > max_name_len {
            format!("{}...", &name[..max_name_len - 3])
        } else {
            name.clone()
        };
        
        let mod_time = chrono::DateTime::<chrono::Local>::from(backup.mod_time)
            .format("%Y-%m-%d %H:%M:%S")
            .to_string();
        
        let size_str = format_size(backup.size);
        
        println!(
            "{}‚îÇ{} {}{:>3}. {:<width1$}{} {}‚îÇ{} {:<width2$} {}‚îÇ{} {:>width3$} {}‚îÇ",
            "".bright_black(), "".clear(),
            "".green(), i + 1, display_name, "".clear(),
            "".bright_black(), "".clear(),
            mod_time,
            "".bright_black(), "".clear(),
            size_str,
            "".bright_black(),
            width1 = max_name_len,
            width2 = COL2_WIDTH,
            width3 = COL3_WIDTH
        );
    }
    
    println!(
        "{}‚îî{}‚î¥{}‚î¥{}‚îò{}\n",
        "".bright_black(),
        "‚îÄ".repeat(COL1_WIDTH + 2),
        "‚îÄ".repeat(COL2_WIDTH + 2),
        "‚îÄ".repeat(COL3_WIDTH + 2),
        "".clear()
    );
    
    Ok(())
}

fn restore_backup(backup_path: &Path, original_path: &Path, config: &Config) -> Result<()> {
    validate_path(original_path, config)?;
    
    let metadata = fs::metadata(backup_path)
        .with_context(|| "Backup file not found")?;
    
    if metadata.len() > config.max_clipboard_size as u64 {
        return Err(anyhow!(
            "Backup file too large to restore (max {}MB)",
            config.max_clipboard_size / (1024 * 1024)
        ));
    }
    
    let content = fs::read(backup_path)?;
    
    if original_path.exists() {
        auto_rename_if_exists(original_path, config)?;
    }
    
    fs::write(original_path, &content)?;
    
    eprintln!("Restored: {} from {}", original_path.display(), backup_path.display());
    println!("‚úÖ Successfully restored: {}", original_path.display());
    println!(
        "üì¶ From backup: {}",
        backup_path.file_name().and_then(|n| n.to_str()).unwrap_or("")
    );
    println!("üìÑ Content size: {} characters", content.len());
    
    Ok(())
}

fn handle_remove_command(filename: &str, config: &Config) -> Result<()> {
    let file_path = resolve_file_path(filename, config)?;
    
    let metadata = fs::metadata(&file_path)
        .with_context(|| format!("File not found: {}", file_path.display()))?;
    
    if metadata.is_dir() {
        return Err(anyhow!("Cannot remove directories, only files"));
    }
    
    if metadata.len() > 0 {
        auto_rename_if_exists(&file_path, config)?;
    }
    
    let content = fs::read(&file_path)?;
    
    fs::remove_file(&file_path)?;
    
    eprintln!("File deleted: {} ({} bytes)", file_path.display(), content.len());
    println!("üóëÔ∏è  File deleted: {}", file_path.display());
    
    File::create(&file_path)?;
    
    eprintln!("Created empty placeholder: {}", file_path.display());
    println!("üìÑ Created empty placeholder: {}", file_path.display());
    println!(
        "‚ÑπÔ∏è  Original content ({} bytes) backed up to ./{}/"  ,
        content.len(),
        config.backup_dir_name
    );
    
    Ok(())
}

fn handle_config_command(subcommand: &ConfigCommands, config: &Config) -> Result<()> {
    match subcommand {
        ConfigCommands::Init { path } => {
            let config_path = path.as_deref().unwrap_or("pt.yml");
            let config_path = Path::new(config_path);
            
            if config_path.exists() {
                println!(
                    "{}‚ö†Ô∏è  Warning: Config file already exists: {}{}",
                    "".yellow(),
                    config_path.display(),
                    "".clear()
                );
                print!("Overwrite? (y/N): ");
                io::stdout().flush()?;
                
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                let input = input.trim().to_lowercase();
                
                if input != "y" && input != "yes" {
                    println!("‚ùå Cancelled");
                    return Ok(());
                }
            }
            
            generate_sample_config(config_path)?;
            
            println!(
                "‚úÖ Sample config file created: {}{}{}",
                "".green(),
                config_path.display(),
                "".clear()
            );
            println!("üìù Edit this file to customize PT behavior");
        }
        
        ConfigCommands::Show => {
            println!("\n{}Current PT Configuration:{}\n", "".bold(), "".clear());
            println!(
                "{}Max Clipboard Size:{} {} bytes ({:.1} MB)",
                "".cyan(),
                "".clear(),
                config.max_clipboard_size,
                config.max_clipboard_size as f64 / (1024.0 * 1024.0)
            );
            println!(
                "{}Max Backup Count:{} {}",
                "".cyan(),
                "".clear(),
                config.max_backup_count
            );
            println!(
                "{}Max Filename Length:{} {} characters",
                "".cyan(),
                "".clear(),
                config.max_filename_length
            );
            println!(
                "{}Backup Directory:{} {}/",
                "".cyan(),
                "".clear(),
                config.backup_dir_name
            );
            println!(
                "{}Max Search Depth:{} {} levels\n",
                "".cyan(),
                "".clear(),
                config.max_search_depth
            );
            
            if let Some(config_path) = find_config_file() {
                println!(
                    "{}Config loaded from:{} {}",
                    "".bright_black(),
                    "".clear(),
                    config_path.display()
                );
            } else {
                println!(
                    "{}Using default configuration (no config file found){}",
                    "".bright_black(),
                    "".clear()
                );
            }
        }
        
        ConfigCommands::Path => {
            if let Some(config_path) = find_config_file() {
                println!(
                    "üìÑ Config file: {}{}{}",
                    "".green(),
                    config_path.display(),
                    "".clear()
                );
            } else {
                println!("{}‚ÑπÔ∏è  No config file found{}", "".bright_black(), "".clear());
                println!("\nSearched in:");
                println!("  ‚Ä¢ ./pt.yml or ./pt.yaml");
                println!("  ‚Ä¢ ~/.config/pt/pt.yml or ~/.config/pt/pt.yaml");
                println!("  ‚Ä¢ ~/pt.yml or ~/pt.yaml");
                println!("\n{}Create one with:{} pt config init", "".cyan(), "".clear());
            }
        }
    }
    
    Ok(())
}

fn print_help() {
    println!("{}PT - Clipboard to File Tool with Smart Version Management v{}{}\n", "".bold(), VERSION, "".clear());
    println!("Usage:");
    println!("  pt <filename>                    Write clipboard to file");
    println!("  pt <filename> -c                 Write only if content differs (check mode)");
    println!("  pt + <filename>                  Append clipboard to file");
    println!("  pt list <filename>               List backups");
    println!("  pt restore <filename>            Restore backup (interactive)");
    println!("  pt restore <filename> --last     Restore last backup");
    println!("  pt diff <filename>               Compare file with backup (interactive)");
    println!("  pt diff <filename> --last        Compare file with last backup");
    println!("  pt remove <filename>             Delete file (with backup) and create empty placeholder");
    println!("  pt tree [path]                   Show directory tree with file sizes");
    println!("  pt tree [path] -e file1,file2    Tree with exceptions (comma-separated)");
    println!("  pt config <subcommand>           Manage configuration");
    println!("  pt --help                        Show this help");
    println!("  pt --version                     Show version");
    println!("\nConfiguration Commands:");
    println!("  pt config init [path]            Create sample config file (default: pt.yml)");
    println!("  pt config show                   Show current configuration");
    println!("  pt config path                   Show config file location");
    println!("\nExamples:");
    println!("  pt notes.txt                     # Save clipboard to notes.txt");
    println!("  pt notes.txt -c                  # Save only if content changed");
    println!("  pt + log.txt                     # Append clipboard to log.txt");
    println!("  pt list notes.txt                # List all backups");
    println!("  pt restore notes.txt             # Interactive restore");
    println!("  pt restore notes.txt --last      # Restore most recent backup");
    println!("  pt diff notes.txt                # Interactive diff with backup");
    println!("  pt diff notes.txt --last         # Diff with most recent backup");
    println!("  pt remove notes.txt              # Delete notes.txt (backup first)");
    println!("  pt tree                          # Show tree of current directory");
    println!("  pt tree /path/to/dir             # Show tree of specific directory");
    println!("  pt tree -e node_modules,.git     # Tree excluding node_modules and .git");
    println!("  pt config init                   # Create pt.yml config file");
    println!("  pt config show                   # View current settings");
    println!("\n{}Features:{}", "".bold(), "".clear());
    println!("  ‚Ä¢ {}Recursive Search:{} If file not in current dir, searches subdirectories", "".cyan(), "".clear());
    println!("  ‚Ä¢ {}Integrated Diff:{} Built-in diff support with colored output", "".cyan(), "".clear());
    println!("  ‚Ä¢ {}Tree View:{} Display directory structure with file sizes", "".cyan(), "".clear());
    println!("  ‚Ä¢ {}Gitignore Support:{} Respects .gitignore patterns in tree view", "".cyan(), "".clear());
    println!("  ‚Ä¢ {}Safe Delete:{} Backup before delete, create empty placeholder", "".cyan(), "".clear());
    println!("  ‚Ä¢ {}Configurable:{} Customize via pt.yml config file", "".cyan(), "".clear());
    println!("  ‚Ä¢ {}Check Mode:{} Skip write if content unchanged (save disk space)", "".cyan(), "".clear());
}

fn main() -> Result<()> {
    let config = load_config();
    
    let args: Vec<String> = std::env::args().collect();
    
    // Handle special cases for backward compatibility
    if args.len() >= 2 {
        match args[1].as_str() {
            "--help" | "-h" => {
                print_help();
                return Ok(());
            }
            "--version" | "-v" => {
                println!("PT version {}", VERSION);
                println!("Production-hardened clipboard to file tool");
                println!("Features: Recursive search, backup management, integrated diff, tree view, safe delete, configurable");
                return Ok(());
            }
            "+" if args.len() >= 3 => {
                let text = get_clipboard_text(&config)?;
                if text.is_empty() {
                    println!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", "".yellow(), "".clear());
                    std::process::exit(1);
                }
                
                let file_path = resolve_file_path(&args[2], &config)
                    .unwrap_or_else(|_| PathBuf::from(&args[2]));
                
                write_file(&file_path, &text, true, false, &config)?;
                return Ok(());
            }
            "-l" | "--list" if args.len() >= 3 => {
                let file_path = resolve_file_path(&args[2], &config)?;
                let backups = list_backups(&file_path, &config)?;
                
                if backups.is_empty() {
                    println!(
                        "‚ÑπÔ∏è  No backups found for: {} (check ./{}/ directory)",
                        file_path.display(),
                        config.backup_dir_name
                    );
                } else {
                    print_backup_table(&file_path, &backups, &config)?;
                }
                return Ok(());
            }
            "-r" | "--restore" if args.len() >= 3 => {
                let filename = &args[2];
                let use_last = args.len() >= 4 && args[3] == "--last";
                
                let file_path = resolve_file_path(filename, &config)
                    .unwrap_or_else(|_| PathBuf::from(filename));
                
                let backups = list_backups(&file_path, &config)?;
                
                if backups.is_empty() {
                    return Err(anyhow!(
                        "No backups found for: {} (check ./{}/ directory)",
                        file_path.display(),
                        config.backup_dir_name
                    ));
                }
                
                if use_last {
                    restore_backup(&backups[0].path, &file_path, &config)?;
                } else {
                    print_backup_table(&file_path, &backups, &config)?;
                    
                    print!("Enter backup number to restore (1-{}) or 0 to cancel: ", backups.len());
                    io::stdout().flush()?;
                    
                    let mut input = String::new();
                    io::stdin().read_line(&mut input)?;
                    
                    let choice: usize = input.trim().parse()
                        .with_context(|| "Invalid input: please enter a number")?;
                    
                    if choice == 0 {
                        println!("‚ùå Restore cancelled");
                        return Ok(());
                    }
                    
                    if choice > backups.len() {
                        return Err(anyhow!("Invalid selection: must be between 0 and {}", backups.len()));
                    }
                    
                    restore_backup(&backups[choice - 1].path, &file_path, &config)?;
                }
                return Ok(());
            }
            "-d" | "--diff" if args.len() >= 3 => {
                let use_last = args.len() >= 4 && args[3] == "--last";
                handle_diff_command(&args[2], use_last, &config)?;
                return Ok(());
            }
            "-rm" | "--remove" if args.len() >= 3 => {
                handle_remove_command(&args[2], &config)?;
                return Ok(());
            }
            "-t" | "--tree" => {
                let path = args.get(2).cloned();
                let exceptions = args.iter()
                    .position(|a| a == "-e" || a == "--exception")
                    .and_then(|i| args.get(i + 1).cloned());
                handle_tree_command(path, exceptions, &config)?;
                return Ok(());
            }
            _ => {}
        }
    }
    
    // Parse with clap
    let cli = Cli::parse();
    
    match cli.command {
        Some(Commands::Append { filename }) => {
            let text = get_clipboard_text(&config)?;
            if text.is_empty() {
                println!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", "".yellow(), "".clear());
                std::process::exit(1);
            }
            
            let file_path = resolve_file_path(&filename, &config)
                .unwrap_or_else(|_| PathBuf::from(&filename));
            
            write_file(&file_path, &text, true, false, &config)?;
        }
        
        Some(Commands::List { filename }) => {
            let file_path = resolve_file_path(&filename, &config)?;
            let backups = list_backups(&file_path, &config)?;
            
            if backups.is_empty() {
                println!(
                    "‚ÑπÔ∏è  No backups found for: {} (check ./{}/ directory)",
                    file_path.display(),
                    config.backup_dir_name
                );
            } else {
                print_backup_table(&file_path, &backups, &config)?;
            }
        }
        
        Some(Commands::Restore { filename, last }) => {
            let file_path = resolve_file_path(&filename, &config)
                .unwrap_or_else(|_| PathBuf::from(&filename));
            
            let backups = list_backups(&file_path, &config)?;
            
            if backups.is_empty() {
                return Err(anyhow!(
                    "No backups found for: {} (check ./{}/ directory)",
                    file_path.display(),
                    config.backup_dir_name
                ));
            }
            
            if last {
                restore_backup(&backups[0].path, &file_path, &config)?;
            } else {
                print_backup_table(&file_path, &backups, &config)?;
                
                print!("Enter backup number to restore (1-{}) or 0 to cancel: ", backups.len());
                io::stdout().flush()?;
                
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                
                let choice: usize = input.trim().parse()
                    .with_context(|| "Invalid input: please enter a number")?;
                
                if choice == 0 {
                    println!("‚ùå Restore cancelled");
                    return Ok(());
                }
                
                if choice > backups.len() {
                    return Err(anyhow!("Invalid selection: must be between 0 and {}", backups.len()));
                }
                
                restore_backup(&backups[choice - 1].path, &file_path, &config)?;
            }
        }
        
        Some(Commands::Diff { filename, last }) => {
            handle_diff_command(&filename, last, &config)?;
        }
        
        Some(Commands::Remove { filename }) => {
            handle_remove_command(&filename, &config)?;
        }
        
        Some(Commands::Tree { path, exceptions }) => {
            handle_tree_command(path, exceptions, &config)?;
        }
        
        Some(Commands::Config { subcommand }) => {
            handle_config_command(&subcommand, &config)?;
        }
        
        None => {
            if let Some(filename) = cli.filename {
                let text = get_clipboard_text(&config)?;
                if text.is_empty() {
                    println!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", "".yellow(), "".clear());
                    std::process::exit(1);
                }
                
                let file_path = resolve_file_path(&filename, &config)
                    .unwrap_or_else(|_| PathBuf::from(&filename));
                
                if cli.check_mode {
                    println!("üîç Check mode enabled - will skip if content identical");
                }
                
                write_file(&file_path, &text, false, cli.check_mode, &config)?;
            } else {
                print_help();
            }
        }
    }
    
    Ok(())
}