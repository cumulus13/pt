// Cargo.toml dependencies:
// [dependencies]
// anyhow = "1.0"
// arboard = "3.2"
// chrono = { version = "0.4", features = ["serde"] }
// colored = "2.0"
// serde = { version = "1.0", features = ["derive"] }
// serde_json = "1.0"
// serde_yaml = "0.9"
// walkdir = "2.3"
// glob = "0.3"
// clap = { version = "4.0", features = ["derive"] }
// terminal_size = "0.3"
// dirs = "4.0"
// rand = "0.8"
// hex = "0.4"

use anyhow::{Context, Result};
use arboard::Clipboard;
use chrono::{DateTime, Local};
use colored::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::io::{self, BufRead, Write};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use walkdir::WalkDir;

const DEFAULT_MAX_CLIPBOARD_SIZE: usize = 100 * 1024 * 1024; // 100MB
const DEFAULT_MAX_BACKUP_COUNT: usize = 100;
const DEFAULT_MAX_FILENAME_LEN: usize = 200;
const DEFAULT_BACKUP_DIR_NAME: &str = "backup";
const DEFAULT_MAX_SEARCH_DEPTH: usize = 10;

#[derive(Debug, Serialize, Deserialize)]
struct Config {
    #[serde(default = "default_max_clipboard_size")]
    max_clipboard_size: usize,
    #[serde(default = "default_max_backup_count")]
    max_backup_count: usize,
    #[serde(default = "default_max_filename_len")]
    max_filename_length: usize,
    #[serde(default = "default_backup_dir_name")]
    backup_dir_name: String,
    #[serde(default = "default_max_search_depth")]
    max_search_depth: usize,
}

fn default_max_clipboard_size() -> usize { DEFAULT_MAX_CLIPBOARD_SIZE }
fn default_max_backup_count() -> usize { DEFAULT_MAX_BACKUP_COUNT }
fn default_max_filename_len() -> usize { DEFAULT_MAX_FILENAME_LEN }
fn default_backup_dir_name() -> String { DEFAULT_BACKUP_DIR_NAME.to_string() }
fn default_max_search_depth() -> usize { DEFAULT_MAX_SEARCH_DEPTH }

impl Default for Config {
    fn default() -> Self {
        Self {
            max_clipboard_size: DEFAULT_MAX_CLIPBOARD_SIZE,
            max_backup_count: DEFAULT_MAX_BACKUP_COUNT,
            max_filename_length: DEFAULT_MAX_FILENAME_LEN,
            backup_dir_name: DEFAULT_BACKUP_DIR_NAME.to_string(),
            max_search_depth: DEFAULT_MAX_SEARCH_DEPTH,
        }
    }
}

#[derive(Debug)]
struct BackupInfo {
    path: PathBuf,
    name: String,
    mod_time: DateTime<Local>,
    size: u64,
    comment: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct BackupMetadata {
    comment: String,
    timestamp: DateTime<Local>,
    size: u64,
    original_file: String,
}

#[derive(Debug)]
struct GitIgnore {
    patterns: Vec<String>,
}

#[derive(Debug)]
struct FileSearchResult {
    path: PathBuf,
    dir: PathBuf,
    size: u64,
    mod_time: DateTime<Local>,
    depth: usize,
}

#[derive(Debug)]
struct TreeNode {
    name: String,
    path: PathBuf,
    is_dir: bool,
    size: u64,
    children: Vec<TreeNode>,
}

fn load_version() -> String {
    let version_paths = vec![
        PathBuf::from("VERSION"),
        std::env::current_exe().ok().map(|p| p.parent().unwrap().join("VERSION")).unwrap_or_default(),
        PathBuf::from("/usr/local/share/pt/VERSION"),
        dirs::home_dir().map(|p| p.join(".local/share/pt/VERSION")).unwrap_or_default(),
        dirs::home_dir().map(|p| p.join(".pt/VERSION")).unwrap_or_default(),
    ];

    for path in version_paths {
        if let Ok(data) = fs::read_to_string(&path) {
            let content = data.trim();
            if !content.is_empty() {
                eprintln!("Version loaded from: {} ({})", path.display(), content);
                return content.to_string();
            }
        }
    }

    eprintln!("VERSION file not found, using 'dev'");
    "dev".to_string()
}

fn find_config_file() -> Option<PathBuf> {
    let config_names = vec!["pt.yml", "pt.yaml", ".pt.yml", ".pt.yaml"];
    let search_paths = vec![
        PathBuf::from("."),
        dirs::home_dir().map(|p| p.join(".config/pt")).unwrap_or_default(),
        dirs::home_dir().unwrap_or_default(),
    ];

    for base_path in search_paths {
        for config_name in &config_names {
            let config_path = base_path.join(config_name);
            if config_path.exists() {
                return Some(config_path);
            }
        }
    }
    None
}

fn load_config() -> Config {
    let mut config = Config::default();

    if let Some(config_path) = find_config_file() {
        eprintln!("Loading config from: {}", config_path.display());
        if let Ok(data) = fs::read_to_string(&config_path) {
            if let Ok(parsed) = serde_yaml::from_str::<Config>(&data) {
                config = parsed;
                // Validate config values
                if config.max_clipboard_size == 0 || config.max_clipboard_size > 1024 * 1024 * 1024 {
                    eprintln!("Warning: invalid max_clipboard_size, using default");
                    config.max_clipboard_size = DEFAULT_MAX_CLIPBOARD_SIZE;
                }
                if config.max_backup_count == 0 || config.max_backup_count > 10000 {
                    eprintln!("Warning: invalid max_backup_count, using default");
                    config.max_backup_count = DEFAULT_MAX_BACKUP_COUNT;
                }
                if config.max_filename_length == 0 || config.max_filename_length > 1000 {
                    eprintln!("Warning: invalid max_filename_length, using default");
                    config.max_filename_length = DEFAULT_MAX_FILENAME_LEN;
                }
                if config.backup_dir_name.is_empty() {
                    eprintln!("Warning: empty backup_dir_name, using default");
                    config.backup_dir_name = DEFAULT_BACKUP_DIR_NAME.to_string();
                }
                if config.max_search_depth == 0 || config.max_search_depth > 100 {
                    eprintln!("Warning: invalid max_search_depth, using default");
                    config.max_search_depth = DEFAULT_MAX_SEARCH_DEPTH;
                }
                return config;
            }
        }
    }

    eprintln!("No config file found, using defaults");
    config
}

fn generate_sample_config(path: &Path) -> Result<()> {
    let config = Config::default();
    let data = serde_yaml::to_string(&config)?;
    let header = r#"# PT Configuration File
# This file configures the behavior of the PT tool
# All values are optional - if not specified, defaults will be used

# Maximum clipboard content size in bytes (default: 104857600 = 100MB)
# Range: 1 - 1073741824 (1GB)
"#;
    let full_content = format!("{}{}", header, data);
    fs::write(path, full_content)?;
    Ok(())
}

fn format_size(size: u64) -> String {
    const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
    let mut size = size as f64;
    let mut unit_index = 0;
    
    while size >= 1024.0 && unit_index < UNITS.len() - 1 {
        size /= 1024.0;
        unit_index += 1;
    }
    
    format!("{:.1} {}", size, UNITS[unit_index])
}

fn generate_short_id() -> String {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let bytes: [u8; 4] = rng.gen();
    hex::encode(bytes)
}

fn validate_path(path: &Path, config: &Config) -> Result<()> {
    if path.to_string_lossy().is_empty() {
        return anyhow::anyhow!("filename cannot be empty");
    }

    let abs_path = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());
    let clean_path = path.clean();
    
    if clean_path.to_string_lossy().contains("..") {
        return anyhow::anyhow!("path traversal not allowed");
    }

    if path.file_name().map_or(0, |n| n.len()) > config.max_filename_length {
        return anyhow::anyhow!("filename too long (max {} characters)", config.max_filename_length);
    }

    let system_dirs = ["/etc", "/sys", "/proc", "/dev"];
    for sys_dir in &system_dirs {
        if abs_path.starts_with(sys_dir) {
            return anyhow::anyhow!("writing to system directories not allowed");
        }
    }

    Ok(())
}

fn ensure_backup_dir(file_path: &Path, config: &Config) -> Result<PathBuf> {
    let dir = if let Some(parent) = file_path.parent() {
        if parent == Path::new("") {
            std::env::current_dir()?
        } else {
            parent.to_path_buf()
        }
    } else {
        std::env::current_dir()?
    };

    let backup_dir = dir.join(&config.backup_dir_name);
    
    if !backup_dir.exists() {
        fs::create_dir_all(&backup_dir)?;
        eprintln!("üìÅ Created backup directory: {}", backup_dir.display());
    } else if !backup_dir.is_dir() {
        return anyhow::anyhow!("backup path exists but is not a directory: {}", backup_dir.display());
    }

    Ok(backup_dir)
}

fn generate_unique_backup_name(file_path: &Path) -> String {
    let base_name = file_path.file_name().unwrap().to_string_lossy();
    let name_without_ext = file_path.file_stem().unwrap().to_string_lossy();
    let ext = file_path.extension().map(|e| format!(".{}", e.to_string_lossy())).unwrap_or_default();
    
    let timestamp = Local::now().format("%Y%m%d_%H%M%S%.6f");
    let timestamp = timestamp.to_string().replace(".", "");
    let unique_id = generate_short_id();
    
    format!("{}_{}_{}.{}", name_without_ext, timestamp, unique_id, ext.trim_start_matches('.'))
}

fn save_backup_metadata(backup_path: &Path, comment: &str, original_file: &Path, size: u64) -> Result<()> {
    let metadata_path = backup_path.with_extension("meta.json");
    let metadata = BackupMetadata {
        comment: comment.to_string(),
        timestamp: Local::now(),
        size,
        original_file: original_file.display().to_string(),
    };
    
    let data = serde_json::to_string_pretty(&metadata)?;
    fs::write(metadata_path, data)?;
    Ok(())
}

fn load_backup_metadata(backup_path: &Path) -> Result<String> {
    let metadata_path = backup_path.with_extension("meta.json");
    if !metadata_path.exists() {
        return Ok(String::new());
    }
    
    let data = fs::read_to_string(metadata_path)?;
    let metadata: BackupMetadata = serde_json::from_str(&data)?;
    Ok(metadata.comment)
}

fn auto_rename_if_exists(file_path: &Path, comment: &str, config: &Config) -> Result<PathBuf> {
    if !file_path.exists() {
        return Ok(file_path.to_path_buf());
    }

    let metadata = fs::metadata(file_path)?;
    if metadata.len() == 0 {
        eprintln!("Skipping backup of empty file: {}", file_path.display());
        return Ok(file_path.to_path_buf());
    }

    let backup_dir = ensure_backup_dir(file_path, config)?;
    let backup_file_name = generate_unique_backup_name(file_path);
    let backup_path = backup_dir.join(&backup_file_name);

    let content = fs::read(file_path)?;
    fs::write(&backup_path, &content)?;
    
    save_backup_metadata(&backup_path, comment, file_path, metadata.len())?;
    
    eprintln!("üì¶ Backup created: {}", backup_file_name.green());
    if !comment.is_empty() {
        eprintln!("üí¨ Comment: \"{}\"", comment.cyan());
    }

    Ok(file_path.to_path_buf())
}

fn get_clipboard_text(config: &Config) -> Result<String> {
    let mut clipboard = Clipboard::new()?;
    let text = clipboard.get_text()?;
    
    if text.len() > config.max_clipboard_size {
        anyhow::bail!("clipboard content too large (max {}MB)", config.max_clipboard_size / (1024 * 1024));
    }
    
    Ok(text)
}

fn write_file(file_path: &Path, data: &str, append_mode: bool, check_mode: bool, comment: &str, config: &Config) -> Result<()> {
    validate_path(file_path, config)?;

    if check_mode && !append_mode {
        if let Ok(existing_data) = fs::read_to_string(file_path) {
            if existing_data == data {
                eprintln!("‚ÑπÔ∏è  Content identical to current file, no changes needed");
                eprintln!("üìÑ File: {}", file_path.display());
                return Ok(());
            }
            eprintln!("üîç Content differs, proceeding with backup and write");
        }
    }

    // Check disk space by trying to create a test file
    let dir = if let Some(parent) = file_path.parent() {
        parent.to_path_buf()
    } else {
        std::env::current_dir()?
    };
    
    let test_file = dir.join(format!(".pt_test_{}", generate_short_id()));
    if fs::File::create(&test_file).is_err() {
        anyhow::bail!("no write permission in directory: {}", dir.display());
    }
    fs::remove_file(test_file)?;

    if !append_mode {
        auto_rename_if_exists(file_path, comment, config)?;
    }

    let mut file = fs::OpenOptions::new()
        .create(true)
        .append(append_mode)
        .write(true)
        .truncate(!append_mode)
        .open(file_path)?;

    let n = file.write(data.as_bytes())?;
    if n != data.len() {
        anyhow::bail!("incomplete write: wrote {} bytes, expected {}", n, data.len());
    }

    file.sync_all()?;
    
    let action = if append_mode { "appended to" } else { "written to" };
    eprintln!("‚úÖ Successfully {}: {}", action, file_path.display());
    eprintln!("üìÑ Content size: {} characters", data.len());

    Ok(())
}

fn resolve_file_path(filename: &str, config: &Config) -> Result<PathBuf> {
    let path = Path::new(filename);
    if path.exists() && path.is_file() {
        return Ok(path.canonicalize()?);
    }

    eprintln!("{}üîç Searching for '{}' in subdirectories...{}", "üîç".blue(), filename, " ".reset());
    
    let results = search_file_recursive(filename, config.max_search_depth)?;
    
    if results.is_empty() {
        anyhow::bail!("file '{}' not found in current directory or subdirectories", filename);
    }

    if results.len() == 1 {
        eprintln!("{}‚úì Found: {}{}", "‚úì".green(), results[0].path.display(), " ".reset());
        return Ok(results[0].path.clone());
    }

    print_file_search_results(&results);
    
    eprint!("Enter file number to use (1-{}) or 0 to cancel: ", results.len());
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    let choice: usize = input.trim().parse()?;
    
    if choice == 0 || choice > results.len() {
        anyhow::bail!("operation cancelled");
    }

    Ok(results[choice - 1].path.clone())
}

fn search_file_recursive(filename: &str, max_depth: usize) -> Result<Vec<FileSearchResult>> {
    let mut results = Vec::new();
    let cwd = std::env::current_dir()?;
    let current_path = cwd.join(filename);
    
    if let Ok(metadata) = fs::metadata(&current_path) {
        if metadata.is_file() {
            results.push(FileSearchResult {
                path: current_path,
                dir: cwd.clone(),
                size: metadata.len(),
                mod_time: metadata.modified()?.into(),
                depth: 0,
            });
        }
    }

    for entry in WalkDir::new(&cwd).max_depth(max_depth).into_iter().filter_map(|e| e.ok()) {
        if entry.path().is_dir() && entry.file_name() == DEFAULT_BACKUP_DIR_NAME {
            continue;
        }
        
        if entry.depth() > max_depth {
            continue;
        }

        if entry.file_name() == filename && entry.path().is_file() {
            if entry.path() == current_path.as_path() {
                continue;
            }

            let rel_path = entry.path().strip_prefix(&cwd)?;
            let depth = rel_path.components().count() - 1;

            results.push(FileSearchResult {
                path: entry.path().to_path_buf(),
                dir: entry.path().parent().unwrap().to_path_buf(),
                size: entry.metadata()?.len(),
                mod_time: entry.metadata()?.modified()?.into(),
                depth,
            });
        }
    }

    Ok(results)
}

fn print_file_search_results(results: &[FileSearchResult]) {
    eprintln!("\n{}üîç Found {} file(s):{}\n", "üîç".cyan(), results.len(), " ".reset());
    
    eprintln!("{}‚îå{}‚î¨{}‚î¨{}‚îê{}", "‚îå".gray(), "‚îÄ".repeat(60), "‚îÄ".repeat(19), "‚îÄ".repeat(12), "‚îê".gray());
    eprintln!("{}‚îÇ{}{} {}Path{}{} ‚îÇ{}{} {}Modified{}{} ‚îÇ{}{} {}Size{}{} ‚îÇ{}", 
        "‚îÇ".gray(), " ".reset(), "Path".yellow().bold(), " ".reset(), " ".repeat(55),
        "‚îÇ".gray(), " ".reset(), "Modified".yellow().bold(), " ".reset(), " ".repeat(10),
        "‚îÇ".gray(), " ".reset(), "Size".yellow().bold(), " ".reset(), " ".repeat(8),
        "‚îÇ".gray());
    eprintln!("{}‚îú{}‚îº{}‚îº{}‚î§{}", "‚îú".gray(), "‚îÄ".repeat(60), "‚îÄ".repeat(19), "‚îÄ".repeat(12), "‚î§".gray());

    for (i, result) in results.iter().enumerate() {
        let cwd = std::env::current_dir().unwrap_or_default();
        let rel_path = result.path.strip_prefix(&cwd).unwrap_or(&result.path);
        let display_path = format!("{}", rel_path.display());
        let truncated_path = if display_path.len() > 57 {
            format!("...{}", &display_path[display_path.len() - 54..])
        } else {
            display_path
        };

        eprintln!("{}‚îÇ{}{:3}. {:<56} ‚îÇ{}{:<19} ‚îÇ{}{:>12} ‚îÇ{}", 
            "‚îÇ".gray(), " ".reset(), i + 1, truncated_path,
            "‚îÇ".gray(), " ".reset(), result.mod_time.format("%Y-%m-%d %H:%M:%S"),
            "‚îÇ".gray(), " ".reset(), format_size(result.size),
            "‚îÇ".gray());
    }

    eprintln!("{}‚îî{}‚î¥{}‚î¥{}‚îò{}\n", "‚îî".gray(), "‚îÄ".repeat(60), "‚îÄ".repeat(19), "‚îÄ".repeat(12), "‚îò".gray());
}

fn list_backups(file_path: &Path, config: &Config) -> Result<Vec<BackupInfo>> {
    validate_path(file_path, config)?;
    
    let dir = file_path.parent().unwrap_or(&Path::new("."));
    let backup_dir = dir.join(&config.backup_dir_name);
    
    if !backup_dir.exists() {
        return Ok(Vec::new());
    }

    let base_name = file_path.file_name().unwrap().to_string_lossy();
    let ext = file_path.extension().map(|e| format!(".{}", e.to_string_lossy())).unwrap_or_default();
    let name_without_ext = file_path.file_stem().unwrap().to_string_lossy();
    let pattern = format!("{}_{}.", name_without_ext, ext.trim_start_matches('.'));

    let mut backups = Vec::new();
    
    for entry in fs::read_dir(&backup_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_dir() {
            continue;
        }
        
        if path.extension().map_or(false, |ext| ext == "meta.json") {
            continue;
        }
        
        let name = entry.file_name().to_string_lossy().to_string();
        if !name.starts_with(&pattern) {
            continue;
        }

        let metadata = entry.metadata()?;
        let comment = load_backup_metadata(&path).unwrap_or_default();

        backups.push(BackupInfo {
            path: path.clone(),
            name,
            mod_time: metadata.modified()?.into(),
            size: metadata.len(),
            comment,
        });
    }

    backups.sort_by(|a, b| b.mod_time.cmp(&a.mod_time));
    backups.truncate(config.max_backup_count);

    Ok(backups)
}

fn print_backup_table(file_path: &Path, backups: &[BackupInfo], config: &Config) {
    eprintln!("\n{}üìÇ Backup files for '{}{}{}'{}",
        "üìÇ".cyan(), " ".bold(), file_path.display(), " ".reset(), "üìÇ".cyan());
    eprintln!("{}Total: {} backup(s) (stored in ./{}/){}\n", 
        "Total:".gray(), backups.len(), config.backup_dir_name, " ".reset());

    let col_widths = [40, 19, 12, 30];
    eprintln!("{}‚îå{}‚î¨{}‚î¨{}‚î¨{}‚îê{}", 
        "‚îå".gray(),
        "‚îÄ".repeat(col_widths[0] + 2),
        "‚îÄ".repeat(col_widths[1] + 2),
        "‚îÄ".repeat(col_widths[2] + 2),
        "‚îÄ".repeat(col_widths[3] + 2),
        "‚îê".gray());
    
    eprintln!("{}‚îÇ{}{} {:<38} ‚îÇ{}{} {:<17} ‚îÇ{}{} {:<10} ‚îÇ{}{} {:<28} ‚îÇ{}",
        "‚îÇ".gray(), " ".reset(), "File Name".yellow().bold(),
        "‚îÇ".gray(), " ".reset(), "Modified".yellow().bold(),
        "‚îÇ".gray(), " ".reset(), "Size".yellow().bold(),
        "‚îÇ".gray(), " ".reset(), "Comment".yellow().bold(),
        "‚îÇ".gray());
    
    eprintln!("{}‚îú{}‚îº{}‚îº{}‚îº{}‚î§{}", 
        "‚îú".gray(),
        "‚îÄ".repeat(col_widths[0] + 2),
        "‚îÄ".repeat(col_widths[1] + 2),
        "‚îÄ".repeat(col_widths[2] + 2),
        "‚îÄ".repeat(col_widths[3] + 2),
        "‚î§".gray());

    for (i, backup) in backups.iter().enumerate() {
        let name = if backup.name.len() > 38 {
            format!("{}...", &backup.name[..35])
        } else {
            backup.name.clone()
        };
        
        let comment = if backup.comment.is_empty() {
            "-".to_string()
        } else if backup.comment.len() > 28 {
            format!("{}...", &backup.comment[..25])
        } else {
            backup.comment.clone()
        };

        eprintln!("{}‚îÇ{}{:3}. {:<36} ‚îÇ{}{:<17} ‚îÇ{}{:>10} ‚îÇ{}{:<28} ‚îÇ{}",
            "‚îÇ".gray(), " ".reset(), i + 1, name,
            "‚îÇ".gray(), " ".reset(), backup.mod_time.format("%Y-%m-%d %H:%M:%S"),
            "‚îÇ".gray(), " ".reset(), format_size(backup.size),
            "‚îÇ".gray(), " ".reset(), comment,
            "‚îÇ".gray());
    }

    eprintln!("{}‚îî{}‚î¥{}‚î¥{}‚î¥{}‚îò{}\n", 
        "‚îî".gray(),
        "‚îÄ".repeat(col_widths[0] + 2),
        "‚îÄ".repeat(col_widths[1] + 2),
        "‚îÄ".repeat(col_widths[2] + 2),
        "‚îÄ".repeat(col_widths[3] + 2),
        "‚îò".gray());
}

fn restore_backup(backup_path: &Path, original_path: &Path, comment: &str, config: &Config) -> Result<()> {
    validate_path(original_path, config)?;
    
    let metadata = fs::metadata(backup_path)?;
    if metadata.len() > config.max_clipboard_size as u64 {
        anyhow::bail!("backup file too large to restore (max {}MB)", config.max_clipboard_size / (1024 * 1024));
    }

    let content = fs::read(backup_path)?;
    
    if original_path.exists() {
        let backup_comment = if comment.is_empty() { "Backup before restore" } else { comment };
        auto_rename_if_exists(original_path, backup_comment, config)?;
    }

    fs::write(original_path, &content)?;
    
    eprintln!("{}‚úÖ Successfully restored: {}", "‚úÖ".green(), original_path.display());
    eprintln!("{}üì¶ From backup: {}", "üì¶".cyan(), backup_path.file_name().unwrap().to_string_lossy());
    eprintln!("{}üìÑ Content size: {} characters", "üìÑ".cyan(), content.len());
    
    if !comment.is_empty() {
        eprintln!("{}üí¨ Restore comment: \"{}\"", "üí¨".cyan(), comment);
    }

    Ok(())
}

fn load_gitignore(root_path: &Path) -> Result<GitIgnore> {
    let gitignore_path = root_path.join(".gitignore");
    let mut patterns = Vec::new();
    
    if let Ok(content) = fs::read_to_string(&gitignore_path) {
        for line in content.lines() {
            let line = line.trim();
            if !line.is_empty() && !line.starts_with('#') {
                patterns.push(line.to_string());
            }
        }
    }
    
    Ok(GitIgnore { patterns })
}

impl GitIgnore {
    fn should_ignore(&self, path: &Path, is_dir: bool) -> bool {
        let base_name = path.file_name().unwrap_or_default().to_string_lossy();
        
        for pattern in &self.patterns {
            if pattern.ends_with('/') {
                let dir_pattern = pattern.trim_end_matches('/');
                if is_dir && (base_name == dir_pattern || base_name.starts_with(dir_pattern)) {
                    return true;
                }
                continue;
            }
            
            if pattern.contains('*') {
                if let Ok(matched) = glob::Pattern::new(pattern).map(|p| p.matches(&base_name)) {
                    if matched {
                        return true;
                    }
                }
                continue;
            }
            
            if base_name == *pattern {
                return true;
            }
            
            let path_str = path.display().to_string();
            if path_str.contains(&format!("/{}/", pattern)) || path_str.contains(&format!("\\{}\\", pattern)) {
                return true;
            }
        }
        
        false
    }
}

fn build_tree(path: &Path, gitignore: Option<&GitIgnore>, exceptions: &HashMap<String, bool>, depth: usize, max_depth: usize) -> Result<Option<TreeNode>> {
    if depth > max_depth {
        return Ok(None);
    }

    let metadata = fs::metadata(path)?;
    let base_name = path.file_name().unwrap_or_default().to_string_lossy().to_string();
    
    if exceptions.contains_key(&base_name) {
        return Ok(None);
    }
    
    if let Some(gi) = gitignore {
        if gi.should_ignore(path, metadata.is_dir()) {
            return Ok(None);
        }
    }

    let mut node = TreeNode {
        name: base_name,
        path: path.to_path_buf(),
        is_dir: metadata.is_dir(),
        size: metadata.len(),
        children: Vec::new(),
    };

    if metadata.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            let child_path = entry.path();
            if let Some(child_node) = build_tree(&child_path, gitignore, exceptions, depth + 1, max_depth)? {
                node.children.push(child_node);
            }
        }

        node.children.sort_by(|a, b| {
            if a.is_dir != b.is_dir {
                b.is_dir.cmp(&a.is_dir)
            } else {
                a.name.cmp(&b.name)
            }
        });
    }

    Ok(Some(node))
}

fn print_tree(node: &TreeNode, prefix: &str, is_last: bool, show_size: bool) {
    let connector = if is_last { "‚îî‚îÄ‚îÄ " } else { "‚îú‚îÄ‚îÄ " };
    
    let display_name = if node.is_dir {
        format!("{}/", node.name.cyan())
    } else {
        format!("{}", node.name.green())
    };
    
    let size_str = if show_size && !node.is_dir {
        format!(" ({})", format_size(node.size).gray())
    } else {
        String::new()
    };

    println!("{}{}{}{}", prefix, connector, display_name, size_str);

    if node.is_dir && !node.children.is_empty() {
        let child_prefix = format!("{}{}", prefix, if is_last { "    " } else { "‚îÇ   " });
        for (i, child) in node.children.iter().enumerate() {
            print_tree(child, &child_prefix, i == node.children.len() - 1, show_size);
        }
    }
}

fn handle_tree_command(args: &[String], config: &Config) -> Result<()> {
    let mut exceptions = HashMap::new();
    let mut start_path = PathBuf::from(".");
    let mut i = 0;
    
    while i < args.len() {
        if args[i] == "-e" || args[i] == "--exception" {
            if i + 1 >= args.len() {
                anyhow::bail!("-e/--exception requires a value");
            }
            i += 1;
            for exc in args[i].split(',') {
                exceptions.insert(exc.trim().to_string(), true);
            }
        } else {
            start_path = PathBuf::from(&args[i]);
        }
        i += 1;
    }

    let abs_path = start_path.canonicalize()?;
    let metadata = fs::metadata(&abs_path)?;
    
    let gitignore = if metadata.is_dir() {
        load_gitignore(&abs_path).ok()
    } else {
        None
    };

    let tree = build_tree(&abs_path, gitignore.as_ref(), &exceptions, 0, config.max_search_depth)?
        .ok_or_else(|| anyhow::anyhow!("no files to display"))?;

    println!("\n{}{}{}", " ".bold(), tree.name.bold(), " ".reset());
    if tree.is_dir && !tree.children.is_empty() {
        for (i, child) in tree.children.iter().enumerate() {
            print_tree(child, "", i == tree.children.len() - 1, true);
        }
    }
    println!();

    // Count statistics
    let mut file_count = 0;
    let mut dir_count = 0;
    let mut total_size = 0u64;
    
    fn count_nodes(node: &TreeNode, file_count: &mut usize, dir_count: &mut usize, total_size: &mut u64) {
        if node.is_dir {
            *dir_count += 1;
            for child in &node.children {
                count_nodes(child, file_count, dir_count, total_size);
            }
        } else {
            *file_count += 1;
            *total_size += node.size;
        }
    }
    
    count_nodes(&tree, &mut file_count, &mut dir_count, &mut total_size);
    
    println!("{} directories, {} files, {} total", 
        dir_count.to_string().gray(), 
        file_count.to_string().gray(), 
        format_size(total_size).gray());

    if !exceptions.is_empty() {
        let exc_list: Vec<_> = exceptions.keys().cloned().collect();
        println!("{}Exceptions: {}{}", "Exceptions:".gray(), exc_list.join(", "), " ".reset());
    }

    if let Some(gi) = gitignore {
        if !gi.patterns.is_empty() {
            println!("{}Using .gitignore ({} patterns){}", "Using .gitignore".gray(), gi.patterns.len(), " ".reset());
        }
    }

    Ok(())
}

fn check_delta_installed() -> bool {
    Command::new("delta")
        .arg("--version")
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .is_ok()
}

fn run_delta(file1: &Path, file2: &Path) -> Result<()> {
    if !check_delta_installed() {
        anyhow::bail!("delta is not installed. Install it from: https://github.com/dandavison/delta");
    }

    // Get terminal width for optimal side-by-side display
    let width = terminal_size::terminal_size()
        .map(|(w, _)| w.0 as usize)
        .unwrap_or(120); // Default width if terminal size detection fails

    // Construct the delta command with explicit side-by-side configuration
    let status = Command::new("delta")
        // Core flags for 2-column view
        .arg("--side-by-side")
        .arg("--width")
        .arg(width.to_string())
        
        // Additional flags to ensure clean output (not like traditional git diff)
        .arg("--no-gitconfig")  // Ignore git config to ensure consistent behavior
        .arg("--line-numbers")  // Show line numbers for clarity
        
        // File arguments
        .arg(file1.to_string_lossy().as_ref())
        .arg(file2.to_string_lossy().as_ref())
        
        // Inherit all I/O for proper terminal integration
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .stdin(Stdio::inherit())
        .status()?;

    // Handle delta's exit codes:
    // - 0: Files are identical
    // - 1: Files differ (this is NORMAL and expected, like git diff)
    // - Other: Actual error
    if let Some(code) = status.code() {
        if code == 1 {
            return Ok(()); // Success case: files differed
        }
    }

    if !status.success() {
        anyhow::bail!("delta execution failed");
    }

    Ok(())
}

fn handle_diff_command(args: &[String], config: &Config) -> Result<()> {
    if args.is_empty() {
        anyhow::bail!("filename required for diff command");
    }

    let filename = &args[0];
    let use_last = args.get(1).map_or(false, |a| a == "--last");

    let file_path = resolve_file_path(filename, config)?;
    let backups = list_backups(&file_path, config)?;

    if backups.is_empty() {
        anyhow::bail!("no backups found for: {} (check ./{}/ directory)", 
            file_path.display(), config.backup_dir_name);
    }

    let selected_backup = if use_last {
        eprintln!("{}üìä Comparing with last backup: {}{}", 
            "üìä".cyan(), backups[0].name, " ".reset());
        &backups[0]
    } else {
        print_backup_table(&file_path, &backups, config);
        
        eprint!("Enter backup number to compare (1-{}) or 0 to cancel: ", backups.len());
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let choice: usize = input.trim().parse()?;
        
        if choice == 0 || choice > backups.len() {
            anyhow::bail!("diff cancelled");
        }
        
        eprintln!("\n{}üìä Comparing with: {}{}", 
            "üìä".cyan(), backups[choice - 1].name, " ".reset());
        &backups[choice - 1]
    };

    run_delta(&selected_backup.path, &file_path)?;
    Ok(())
}

fn handle_remove_command(args: &[String], config: &Config) -> Result<()> {
    if args.is_empty() {
        anyhow::bail!("filename required for remove command");
    }

    let filename = &args[0];
    let mut comment = String::new();
    
    let mut i = 1;
    while i < args.len() {
        if args[i] == "-m" || args[i] == "--message" {
            if i + 1 >= args.len() {
                anyhow::bail!("-m/--message requires a value");
            }
            comment = args[i + 1].clone();
            i += 1;
        }
        i += 1;
    }

    let file_path = resolve_file_path(filename, config)?;
    let metadata = fs::metadata(&file_path)?;
    
    if metadata.is_dir() {
        anyhow::bail!("cannot remove directories, only files");
    }

    if metadata.len() > 0 {
        let backup_comment = if comment.is_empty() { "Deleted file backup" } else { &comment };
        auto_rename_if_exists(&file_path, backup_comment, config)?;
    }

    let content = fs::read(&file_path)?;
    fs::remove_file(&file_path)?;
    
    eprintln!("{}üóëÔ∏è  File deleted: {}", "üóëÔ∏è".red(), file_path.display());
    
    fs::File::create(&file_path)?;
    eprintln!("{}üìÑ Created empty placeholder: {}", "üìÑ".cyan(), file_path.display());
    eprintln!("{}‚ÑπÔ∏è  Original content ({} bytes) backed up to ./{}/", 
        "‚ÑπÔ∏è".gray(), content.len(), config.backup_dir_name);

    Ok(())
}

fn handle_list_command(filename: &str, config: &Config) -> Result<()> {
    let file_path = resolve_file_path(filename, config)?;
    let backups = list_backups(&file_path, config)?;

    if backups.is_empty() {
        eprintln!("‚ÑπÔ∏è  No backups found for: {} (check ./{}/ directory)", 
            file_path.display(), config.backup_dir_name);
    } else {
        print_backup_table(&file_path, &backups, config);
    }

    Ok(())
}

fn handle_restore_command(args: &[String], config: &Config) -> Result<()> {
    if args.is_empty() {
        anyhow::bail!("filename required for restore command");
    }

    let filename = &args[0];
    let mut comment = String::new();
    let mut use_last = false;
    
    let mut i = 1;
    while i < args.len() {
        if args[i] == "--last" {
            use_last = true;
        } else if args[i] == "-m" || args[i] == "--message" {
            if i + 1 < args.len() {
                comment = args[i + 1].clone();
                i += 1;
            }
        }
        i += 1;
    }

    let file_path = if let Ok(path) = resolve_file_path(filename, config) {
        path
    } else {
        PathBuf::from(filename)
    };

    let backups = list_backups(&file_path, config)?;
    if backups.is_empty() {
        anyhow::bail!("no backups found for: {} (check ./{}/ directory)", 
            file_path.display(), config.backup_dir_name);
    }

    if use_last {
        let restore_comment = if comment.is_empty() { "Restored from last backup" } else { &comment };
        restore_backup(&backups[0].path, &file_path, restore_comment, config)?;
    } else {
        print_backup_table(&file_path, &backups, config);
        
        eprint!("Enter backup number to restore (1-{}) or 0 to cancel: ", backups.len());
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let choice: usize = input.trim().parse()?;
        
        if choice == 0 || choice > backups.len() {
            anyhow::bail!("restore cancelled");
        }

        let restore_comment = if comment.is_empty() { "Restored from backup" } else { &comment };
        restore_backup(&backups[choice - 1].path, &file_path, restore_comment, config)?;
    }

    Ok(())
}

fn handle_config_command(args: &[String], config: &Config) -> Result<()> {
    if args.is_empty() {
        anyhow::bail!("config subcommand required: 'init', 'show', or 'path'");
    }

    match args[0].as_str() {
        "init" => {
            let config_path = if args.len() > 1 {
                PathBuf::from(&args[1])
            } else {
                PathBuf::from("pt.yml")
            };

            if config_path.exists() {
                eprint!("{}‚ö†Ô∏è  Warning: Config file already exists: {}\\nOverwrite? (y/N): ", 
                    "‚ö†Ô∏è".yellow(), config_path.display());
                io::stdout().flush()?;
                
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                if input.trim().to_lowercase() != "y" {
                    eprintln!("‚ùå Cancelled");
                    return Ok(());
                }
            }

            generate_sample_config(&config_path)?;
            eprintln!("{}‚úÖ Sample config file created: {}{}", 
                "‚úÖ".green(), config_path.display().green(), " ".reset());
            eprintln!("{}üìù Edit this file to customize PT behavior{}", "üìù".cyan(), " ".reset());
        }
        
        "show" => {
            eprintln!("\n{}Current PT Configuration:{}\n", "Current PT Configuration:".bold(), " ".reset());
            eprintln!("{}Max Clipboard Size:{} {} bytes ({:.1} MB)", 
                "Max Clipboard Size:".cyan(), " ".reset(), 
                config.max_clipboard_size, config.max_clipboard_size as f64 / (1024.0 * 1024.0));
            eprintln!("{}Max Backup Count:{} {}", 
                "Max Backup Count:".cyan(), " ".reset(), config.max_backup_count);
            eprintln!("{}Max Filename Length:{} {} characters", 
                "Max Filename Length:".cyan(), " ".reset(), config.max_filename_length);
            eprintln!("{}Backup Directory:{} {}/", 
                "Backup Directory:".cyan(), " ".reset(), config.backup_dir_name);
            eprintln!("{}Max Search Depth:{} {} levels\n", 
                "Max Search Depth:".cyan(), " ".reset(), config.max_search_depth);

            if let Some(path) = find_config_file() {
                eprintln!("{}Config loaded from:{}{}", "Config loaded from:".gray(), " ".reset(), path.display());
            } else {
                eprintln!("{}Using default configuration (no config file found){}", 
                    "Using default configuration".gray(), " ".reset());
            }
        }
        
        "path" => {
            if let Some(path) = find_config_file() {
                eprintln!("{}üìÑ Config file: {}{}", "üìÑ".green(), path.display().green(), " ".reset());
            } else {
                eprintln!("{}‚ÑπÔ∏è  No config file found{}", "‚ÑπÔ∏è".gray(), " ".reset());
                eprintln!("\nSearched in:");
                eprintln!("  ‚Ä¢ ./pt.yml or ./pt.yaml");
                eprintln!("  ‚Ä¢ ~/.config/pt/pt.yml or ~/.config/pt/pt.yaml");
                eprintln!("  ‚Ä¢ ~/pt.yml or ~/pt.yaml");
                eprintln!("\n{}Create one with:{} pt config init", "Create one with:".cyan(), " ".reset());
            }
        }
        
        _ => anyhow::bail!("unknown config subcommand: {} (use 'init', 'show', or 'path')", args[0]),
    }

    Ok(())
}

fn print_help(version: &str, config: &Config) {
    eprintln!("{}PT - Clipboard to File Tool with Smart Version Management v{}{}", 
        "PT".bold(), version, " ".reset());
    eprintln!("\nUsage:");
    eprintln!("  pt <filename>                    Write clipboard to file");
    eprintln!("  pt <filename> -c                 Write only if content differs (check mode)");
    eprintln!("  pt <filename> -m \"comment\"       Write with comment");
    eprintln!("  pt <filename> -c -m \"comment\"   Check mode with comment");
    eprintln!("  pt + <filename>                  Append clipboard to file");
    eprintln!("  pt + <filename> -m \"comment\"    Append with comment");
    eprintln!("  pt -l <filename>                 List backups (with comments)");
    eprintln!("  pt -r <filename>                 Restore backup (interactive)");
    eprintln!("  pt -r <filename> --last          Restore last backup");
    eprintln!("  pt -r <filename> -m \"comment\"   Restore with comment");
    eprintln!("  pt -d <filename>                 Compare file with backup (interactive)");
    eprintln!("  pt -d <filename> --last          Compare file with last backup");
    eprintln!("  pt -rm <filename>                Delete file (with backup) and create empty placeholder");
    eprintln!("  pt -t [path]                     Show directory tree with file sizes");
    eprintln!("  pt -t [path] -e file1,file2      Tree with exceptions (comma-separated)");
    eprintln!("  pt config <subcommand>           Manage configuration");
    eprintln!("  pt -h, --help                    Show this help");
    eprintln!("  pt -v, --version                 Show version");
    eprintln!("\nConfiguration Commands:");
    eprintln!("  pt config init [path]            Create sample config file (default: pt.yml)");
    eprintln!("  pt config show                   Show current configuration");
    eprintln!("  pt config path                   Show config file location");
    eprintln!("\nExamples:");
    eprintln!("  pt notes.txt                     # Save clipboard to notes.txt");
    eprintln!("  pt notes.txt -c                  # Save only if content changed");
    eprintln!("  pt notes.txt --check             # Same as above");
    eprintln!("  pt + log.txt                     # Append clipboard to log.txt");
    eprintln!("  pt -l notes.txt                  # List all backups");
    eprintln!("  pt -r notes.txt                  # Interactive restore");
    eprintln!("  pt -r notes.txt --last           # Restore most recent backup");
    eprintln!("  pt -d notes.txt                  # Interactive diff with backup");
    eprintln!("  pt -d notes.txt --last           # Diff with most recent backup");
    eprintln!("  pt -rm notes.txt                 # Delete notes.txt (backup first)");
    eprintln!("  pt -t                            # Show tree of current directory");
    eprintln!("  pt -t /path/to/dir               # Show tree of specific directory");
    eprintln!("  pt -t -e node_modules,.git       # Tree excluding node_modules and .git");
    eprintln!("  pt config init                   # Create pt.yml config file");
    eprintln!("  pt config show                   # View current settings");
    eprintln!("\n{}Features:{}", "Features:".bold(), " ".reset());
    eprintln!("  ‚Ä¢ {}Recursive Search:{} If file not in current dir, searches subdirectories", "Recursive Search:".cyan(), " ".reset());
    eprintln!("  ‚Ä¢ {}Diff Support:{} Uses 'delta' CLI tool for beautiful diffs", "Diff Support:".cyan(), " ".reset());
    eprintln!("  ‚Ä¢ {}Tree View:{} Display directory structure with file sizes", "Tree View:".cyan(), " ".reset());
    eprintln!("  ‚Ä¢ {}Gitignore Support:{} Respects .gitignore patterns in tree view", "Gitignore Support:".cyan(), " ".reset());
    eprintln!("  ‚Ä¢ {}Safe Delete:{} Backup before delete, create empty placeholder", "Safe Delete:".cyan(), " ".reset());
    eprintln!("  ‚Ä¢ {}Configurable:{} Customize via pt.yml config file", "Configurable:".cyan(), " ".reset());
    eprintln!("  ‚Ä¢ {}Check Mode:{} Skip write if content unchanged (save disk space)", "Check Mode:".cyan(), " ".reset());
    eprintln!("\n{}Backup Location: All backups stored in ./{}/ directory{}", 
        "Backup Location:".cyan(), config.backup_dir_name, " ".reset());
    eprintln!("{}Limits: Max file size {}MB, Max {} backups kept{}", 
        "Limits:".gray(), config.max_clipboard_size / (1024 * 1024), config.max_backup_count, " ".reset());
    eprintln!("\n{}Config File Locations (searched in order):{}", 
        "Config File Locations:".gray(), " ".reset());
    eprintln!("  ‚Ä¢ ./pt.yml or ./pt.yaml (current directory)");
    eprintln!("  ‚Ä¢ ~/.config/pt/pt.yml or ~/.config/pt/pt.yaml");
    eprintln!("  ‚Ä¢ ~/pt.yml or ~/pt.yaml (home directory)");
    eprintln!("\n{}Note: Install 'delta' for diff functionality: https://github.com/dandavison/delta{}", 
        "Note:".gray(), " ".reset());
}

fn print_version(version: &str, config: &Config) {
    eprintln!("PT version {}", version);
    eprintln!("Production-hardened clipboard to file tool");
    eprintln!("Features: Recursive search, backup management, delta diff, tree view, safe delete, configurable");
    eprintln!();
    
    if let Ok(exe_path) = std::env::current_exe() {
        let version_path = exe_path.parent().unwrap().join("VERSION");
        if version_path.exists() {
            eprintln!("Version file: {}", version_path.display());
        }
    }
    
    if let Some(path) = find_config_file() {
        eprintln!("Config file: {}", path.display());
    } else {
        eprintln!("Config: Using defaults (no config file)");
    }
}

fn parse_write_args(args: &[String]) -> Result<(String, String, bool)> {
    if args.is_empty() {
        anyhow::bail!("filename required");
    }

    let filename = args[0].clone();
    let mut comment = String::new();
    let mut check_mode = false;
    let mut i = 1;
    
    while i < args.len() {
        match args[i].as_str() {
            "-m" | "--message" => {
                if i + 1 >= args.len() {
                    anyhow::bail!("-m/--message requires a value");
                }
                comment = args[i + 1].clone();
                i += 1;
            }
            "-c" | "--check" => check_mode = true,
            _ => anyhow::bail!("unknown flag: {}", args[i]),
        }
        i += 1;
    }

    Ok((filename, comment, check_mode))
}

fn main() -> Result<()> {
    let version = load_version();
    let config = load_config();

    let args: Vec<String> = std::env::args().collect();
    
    if args.len() == 2 {
        match args[1].as_str() {
            "-h" | "--help" => {
                print_help(&version, &config);
                return Ok(());
            }
            "-v" | "--version" => {
                print_version(&version, &config);
                return Ok(());
            }
            _ => {}
        }
    }

    if args.len() < 2 {
        print_help(&version, &config);
        std::process::exit(1);
    }

    let command = &args[1];
    let cmd_args = &args[2..];

    match command.as_str() {
        "config" => handle_config_command(cmd_args, &config)?,
        
        "-t" | "--tree" => handle_tree_command(cmd_args, &config)?,
        
        "-rm" | "--remove" => handle_remove_command(cmd_args, &config)?,
        
        "-l" | "--list" => {
            if cmd_args.is_empty() {
                eprintln!("{}‚ùå Error: Filename required{}", "‚ùå".red(), " ".reset());
                std::process::exit(1);
            }
            handle_list_command(&cmd_args[0], &config)?;
        }
        
        "-d" | "--diff" => handle_diff_command(cmd_args, &config)?,
        
        "-r" | "--restore" => handle_restore_command(cmd_args, &config)?,
        
        "+" => {
            if cmd_args.is_empty() {
                eprintln!("{}‚ùå Error: Filename required{}", "‚ùå".red(), " ".reset());
                std::process::exit(1);
            }

            let text = get_clipboard_text(&config)?;
            if text.is_empty() {
                eprintln!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", "‚ö†Ô∏è".yellow(), " ".reset());
                std::process::exit(1);
            }

            let filename = &cmd_args[0];
            let mut comment = String::new();
            
            let mut i = 1;
            while i < cmd_args.len() {
                if cmd_args[i] == "-m" || cmd_args[i] == "--message" {
                    if i + 1 < cmd_args.len() {
                        comment = cmd_args[i + 1].clone();
                        i += 1;
                    }
                }
                i += 1;
            }

            let file_path = resolve_file_path(filename, &config).unwrap_or_else(|_| PathBuf::from(filename));
            write_file(&file_path, &text, true, false, &comment, &config)?;
        }
        
        _ => {
            // Default write mode
            let text = get_clipboard_text(&config)?;
            if text.is_empty() {
                eprintln!("{}‚ö†Ô∏è  Warning: Clipboard is empty{}", "‚ö†Ô∏è".yellow(), " ".reset());
                std::process::exit(1);
            }

            let (filename, comment, check_mode) = parse_write_args(cmd_args)?;
            let file_path = resolve_file_path(&filename, &config).unwrap_or_else(|_| PathBuf::from(&filename));
            
            if check_mode {
                eprintln!("üîç Check mode enabled - will skip if content identical");
            }

            write_file(&file_path, &text, false, check_mode, &comment, &config)?;
        }
    }

    Ok(())
}